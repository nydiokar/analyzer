# Wallet Analysis System Refactoring Implementation Plan (Revised)

**Status Update (as of current conversation):** Core logic extraction is largely complete for Behavior, Correlation, Similarity, and PNL/Stats analysis. Reporting Service handles report generation. Scripts for `activityCorrelator`, `wallet-behavior-analyzer`, `kpi-comparison-report`, and `helius-analyzer` have been refactored to use the new services. Database schema changes for User/ActivityLog and `DatabaseService` enhancements are also complete. API endpoints for `/summary` (which includes aggregated metrics, SOL & token balances), `/token-performance` (including current balances), and `/pnl-overview` are implemented with initial Swagger documentation. The dashboard has its basic layout, navigation (collapsible sidebar), global time filter, and key tabs ("Token Performance", "Account Stats & PNL") integrated with the API, and displays current SOL/token balances.

## Recently Completed (Backend & Initial Dashboard Setup)

*   **API Endpoint Logic & Data Presentation Refinement:** `/summary` and `/pnl-overview` reviewed.
*   **`GET /wallets/{walletAddress}/behavior-analysis` API Endpoint Implementation.**
*   **Full API Authentication & User Context Implementation.**
*   **CLI Script for User/API Key Management.**
*   **Dashboard Project Setup & Core Dependencies Integration:** Next.js, TailwindCSS, shadcn/ui, Tremor, ECharts, SWR, Zustand.
*   **Dashboard Layout Skeleton & Basic Routing:** `WalletProfileLayout`, `Sidebar`, `AccountSummaryCard`, `TimeRangeSelector` stubs.
*   **Global Time Filter & Sticky Summary Bar Development.**
*   **Time-Filtering for "Token Performance" Tab (Backend & Frontend).**
*   **Time-Filtering & Dual Display for "Account Stats & PNL" Tab (Backend & Frontend).**
*   **Wallet State Enhancement (SOL & Token Balances):** Integration of SOL and token balance fetching, storage, and display in API/Dashboard and reports.

## Immediate Dashboard Development Focus (Phase 5 Continued)

1.  **Connect "Behavioral Patterns" Tab with Time-Filtering:**
    *   **Goal:** Ensure the behavioral analysis presented in the dashboard is scoped to the user-selected time range.
    *   **Backend Tasks:**
        *   Update the `GET /wallets/{walletAddress}/behavior-analysis` endpoint in `WalletsController` to accept optional `startDate`/`endDate` query parameters. - **LARGELY COMPLETE - Backend accepts time parameters. Verify data returned is correctly scoped.**
        *   Ensure the controller passes these dates to `BehaviorService.getWalletBehavior`. - **LARGELY COMPLETE**
        *   (The core `BehaviorService` and `OriginalBehaviorService` are already capable of using the time range for data fetching and skipping DB upserts). - **VERIFIED**
    *   **Frontend Tasks:**
        *   Connect the "Behavioral Patterns" tab to this endpoint. - **LARGELY COMPLETE**
        *   Ensure the SWR hook for this tab passes the global time filter state. - **LARGELY COMPLETE**
        *   Display the time-scoped behavioral metrics and visualizations (e.g., heatmaps, classifications relevant to the period). - **TO DO: VERIFY DISPLAY & VISUALIZATIONS, IMPLEMENT VISUALIZATIONS**

2.  **Implement "Reviewer Log / Notes" Tab:**
    *   **Goal:** Allow analysts to add and view notes for a specific wallet.
    *   **Backend Tasks (Phase 4 - API):**
        *   Design and implement `POST /wallets/{walletAddress}/notes` and `GET /wallets/{walletAddress}/notes` endpoints.
        *   Consider data storage (new Prisma model or extending existing).
    *   **Frontend Tasks (Phase 5.3 - Week 4):**
        *   Create `ReviewerLogTab.tsx` component.
        *   Implement UI with a textarea (e.g., shadcn/ui `Textarea`) or a simple rich text editor.
        *   Connect to API endpoints for saving/loading notes (with SWR/fetcher).
        *   Implement debounced autosave functionality.

3.  **UX Polish & Refinements (Ongoing):**
    *   Address any outstanding layout/spacing issues based on user feedback.
    *   Ensure consistent loading states, empty states, and error handling across all tabs.
    *   Review and add tooltips where beneficial for clarity.
    *   (Corresponds to Phase 5.3, Week 4 - UX Polish tasks)

## COMPLETED: Wallet State Enhancement (SOL & Token Balances)

**Goal:** Integrate the fetching of current SOL and all associated SPL Token balances for wallets to enrich analysis and provide up-to-date information for the dashboard and CLI scripts. This involved using efficient batch RPC calls.

**Tasks: (ALL COMPLETED)**

1.  **Design `WalletStateService` (or enhance `HeliusApiClient`):**
    *   **Purpose:** Create a dedicated service or extend an existing one to encapsulate the logic for fetching SOL and token balances.
    *   **Method Signature (Example):** `fetchWalletStates(walletAddresses: string[]): Promise<Map<string, WalletState>>`
    *   **`WalletState` Interface:** Define a type like:
        ```typescript
        interface WalletState {
          solBalance: number;
          tokenBalances: Array<{
            mint: string;
            tokenAccountAddress: string; // Address of the specific token account
            balance: string; // Raw amount
            decimals: number;
            uiBalance: number;
            uiBalanceString: string;
          }>;
          fetchedAt: Date;
        }
        ```

2.  **Implement Balance Fetching Logic in the chosen Service/Client:**
    *   **SOL Balances:**
        *   Within the new service/method, use `getMultipleAccounts` RPC call (likely via `HeliusApiClient`) with the list of `walletAddresses` to get their lamport balances. Convert to SOL.
    *   **Token Balances:**
        *   For each `walletAddress` in the input array:
            *   Call `getTokenAccountsByOwner` RPC method (likely via `HeliusApiClient`).
            *   **Crucially, use `encoding: "jsonParsed"`** and provide the `programId` for the SPL Token Program (`TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA`)
            *   Fetching for Token-2022 program (`TokenzQdBNbLqP5VEhdkAS6EPFLC1PHnBqCXEpPxAPds`) has been temporarily removed due to RPC issues and will be revisited.
            *   This will return a list of token accounts, each already containing parsed data including the mint, owner, and balance (`amount`, `decimals`, `uiAmountString`).
            *   Transform this into the `tokenBalances` array for the `WalletState` object.
    *   **Error Handling & Batching:** Ensure robust error handling. `HeliusApiClient` should manage underlying batching for `getMultipleAccounts` and appropriate rate limiting/concurrency for multiple `getTokenAccountsByOwner` calls.

3.  **Integration with `helius-analyzer.ts` (PNL Script & `PnlAnalysisService`):**
    *   **Goal:** Snapshot wallet state at the time of PNL analysis.
    *   Modify `PnlAnalysisService` (or the main script orchestrator in `helius-analyzer.ts`):
        *   During an analysis run (e.g., when `AdvancedStatsResult` is being generated), call the new `fetchWalletStates` method for the target wallet.
        *   Store the fetched `WalletState` (or a relevant subset, e.g., SOL balance and top N token balances by value) as part of `AdvancedStatsResult` or a new related table linked to `AnalysisRun` or `Wallet`.
        *   The `ReportingService` for PNL reports can then include this balance information from the analysis results.

4.  **Integration with `activityCorrelator.ts` and `walletSimilarity.ts` (and their services):**
    *   **Goal:** Use current balances to enrich multi-wallet analysis.
    *   Modify these scripts (or their respective services, `CorrelationService`, `SimilarityService`):
        *   Call `fetchWalletStates` for the list of input wallets at the beginning of their analysis process.
        *   Use the SOL and token balance data:
            *   As additional features for similarity/correlation calculations (e.g., similarity in current holdings).
            *   To provide context in generated reports (e.g., display current SOL/token balances alongside activity patterns).
            *   This data might be used in-memory for the analysis or selectively included in report outputs.

5.  **API & Dashboard Enhancements (Considered for a near-future iteration, post-backend implementation):**
    *   **API Enhancements:** The `GET /wallets/{walletAddress}/summary` endpoint could be enhanced:
        *   Option 1 (Live Data for specific request): Add an optional query parameter (e.g., `includeLiveBalances=true`) to trigger an on-demand call to `fetchWalletStates`. Use with caching.
        *   Option 2 (Snapshot Data): If `PnlAnalysisService` snapshots balances, the `/summary` endpoint can primarily serve this snapshotted data, ensuring consistency with the detailed analysis period. Live data could be a separate, clearly marked feature.
    *   **Dashboard Integration:**
        *   The "General Account Info" / "Sticky Summary Bar" can display the SOL balance (either from snapshot or live, sourced from `/summary` endpoint).
        *   The "Token Performance" tab will be enhanced:
            *   It will display the current UI-friendly balance for each token (data sourced from `AnalysisResult.currentUiBalanceString` which is populated by `PnlAnalysisService` during its run and included in the `/token-performance` API response). This may replace or augment the existing "Net Amount" column.
            *   A frontend filter (e.g., a toggle button) will be added to this tab. When activated, it will filter the displayed tokens to show only those with a current balance greater than zero. This provides a view of current holdings directly within the token performance context.
            *   A separate "Holdings" tab or modal is likely no longer necessary due to this enhancement.
        *   The "Token Performance" tab will continue to show the "Current Holdings Snapshot" section as generated by the `PnlAnalysisService` and included in the PNL report / `/summary` endpoint, providing a full list of all balances at the time of analysis.

**Impact & Rationale:**
*   **Efficiency:** Leverages `getMultipleAccounts` for SOL and `getTokenAccountsByOwner` (with `jsonParsed`) for token balances, which are efficient for these tasks.
*   **Enriched Analysis:** Provides current asset context to historical transaction analysis.
*   **Dashboard Value:** Offers users an up-to-date snapshot of holdings, complementing historical PNL.
*   **Moderate Effort:** This is a self-contained backend enhancement primarily involving RPC interactions and data transformation, fitting well as an immediate focus alongside current dashboard work.

## Phase 1: Core Analysis Logic Extraction (Complete)

### 1.1 Reorganize Existing Types (Complete)
Location: `src/types/`
- Types are consolidated in `analysis.ts`, `behavior.ts`, `correlation.ts`, `similarity.ts`, `wallet.ts`, etc.

### 1.2 Extract Core Analysis Logic (Complete)

#### 1.2.1 Correlation Analysis
Location: `src/wallet_analysis/core/correlation/analyzer.ts`
- `CorrelationAnalyzer` class encapsulates pairwise scoring, clustering, and global token stats calculation, migrated from `activityCorrelator.ts`.

#### 1.2.2 Behavior Analysis
Location: `src/wallet_analysis/core/behavior/analyzer.ts`
- `BehaviorAnalyzer` class encapsulates sequence building, metrics calculation, and classification, migrated from `wallet-behavior-analyzer.ts`.

#### 1.2.3 Similarity Analysis
Location: `src/wallet_analysis/core/similarity/analyzer.ts`
- `SimilarityAnalyzer` class encapsulates vector creation (capital/binary) and similarity scoring (cosine), migrated from `walletSimilarity.ts`.

#### 1.2.4 KPI Reporting Analysis
Location: `src/wallet_analysis/core/reporting/kpi_analyzer.ts`
- `KPIComparisonAnalyzer` encapsulates comparative report generation logic from `kpi-comparison-report.ts`.

### 1.3 Extract Utility Functions (Complete)

#### 1.3.1 PNL Calculation
Location: `src/wallet_analysis/utils/pnl_calculator.ts`
- Contains `calculateWalletPnl` and `calculatePnlForWallets`, extracted from `activityCorrelator.ts`.

#### 1.3.2 Reporting Utilities
Location: `src/wallet_analysis/reporting/report_utils.ts`
- Contains `generateBehaviorReport`, `generateCorrelationReport`, `generateSimilarityReport`, and `saveReport`, consolidating logic from multiple scripts.

## Phase 2: Service Layer Enhancement (Largely Complete)

### 2.1 Analysis Services
Location: `src/wallet_analysis/services/`

#### 2.1.1 `CorrelationService`
- Uses `CorrelationAnalyzer`.
- Integrates database fetching (via `DatabaseService`).
- Integrates bot filtering logic (from `activityCorrelator.ts`).
- Integrates PNL calculation (using `pnl_calculator.ts`).

#### 2.1.2 `BehaviorService`
- Uses `BehaviorAnalyzer`.
- Integrates database fetching (via `DatabaseService`).

#### 2.1.3 `SimilarityService`
- Uses `SimilarityAnalyzer`.
- Integrates database fetching (via `DatabaseService`).
- Integrates shared token analysis (from `walletSimilarity.ts`).

#### 2.1.4 `ReportingService`
- Uses `BehaviorService`, `CorrelationService` (optional), `SimilarityService` (optional), `KPIComparisonAnalyzer`.
- Uses `report_utils.ts` to generate and save various report types (individual behavior, comparative behavior, correlation, similarity).

### 2.2 Enhance Existing Services (Ongoing)

- `DatabaseService`: Refactored into a class. Imports in older scripts like `helius-analyzer.ts` need updating. - **COMPLETE**
- `HeliusApiClient`: Assumed functional based on plan.
- `HeliusTransactionMapper`: Assumed functional based on plan.

## Phase 3: Script Refactoring (Ongoing)

**Goal:** Transform scripts in `src/scripts/` to act as simple orchestrators or entry points that primarily call the new services.

### 3.1 `activityCorrelator.ts`
- **Status: Complete**
- The script now handles CLI argument parsing (wallet source, excludeMints, timeRange).
- It instantiates `DatabaseService`, `CorrelationService`, and `ReportingService`.
- It creates `CorrelationAnalysisConfig` with CLI args.
- It calls `reportingService.generateAndSaveCorrelationReport` to orchestrate the analysis and reporting.
- Internal logic for fetching, filtering, PNL calculation, analysis, clustering, and report generation has been removed.

### 3.2 `wallet-behavior-analyzer.ts`
- **Status: Complete** 
- The script now handles CLI argument parsing (walletAddress, label, excludeMints, timeRange).
- It instantiates `DatabaseService`, `BehaviorService`, and `ReportingService`.
- It creates `BehaviorAnalysisConfig` with CLI args.
- It calls `behaviorService.analyzeWalletBehavior`.
- It calls `reportingService.generateAndSaveIndividualBehaviorReport`.
- Internal logic for fetching, analysis, and reporting has been removed.

### 3.3 `kpi-comparison-report.ts`
- **Status: Complete** 
- The script now handles CLI argument parsing (walletList file, excludeMints, timeRange).
- It instantiates `DatabaseService`, `BehaviorService`, `KPIComparisonAnalyzer`, and `ReportingService`.
- It creates `BehaviorAnalysisConfig` with CLI args.
- It calls `reportingService.generateComparativeBehaviorReport`.
- Internal logic for fetching, analysis, and reporting has been removed.

### 3.4 `walletSimilarity.ts`
- **Status: To Do**
- **Goal:** Update `main` function to orchestrate service calls.
- **Required Refactoring Steps:**
    - Parse CLI args (wallet source, vector type, potentially timeRange/excludeMints).
    - Instantiate `DatabaseService` and `SimilarityService`.
    - Create `SimilarityAnalysisConfig` (potentially including timeRange/excludeMints).
    - Instantiate `ReportingService` (injecting `SimilarityService`).
    - Call `reportingService.generateAndSaveSimilarityReport(walletAddresses, vectorType)`.
    - Remove internal logic for fetching, shared token analysis, vector creation, similarity calc, and reporting.

### 3.5 `helius-analyzer.ts`
- **Status: Complete**
- **Description:** The script has been refactored to act as an orchestrator, leveraging dedicated services (`HeliusSyncService`, `PnlAnalysisService`, `ReportingService`, `DatabaseService`) for data synchronization, analysis, and reporting, preserving previous functionalities like fetching modes and CSV export.
- **Key Components Used:**
    - `HeliusSyncService`: Manages data fetching, mapping, and storage.
    - `PnlAnalysisService`: Orchestrates P/L and stats calculation.
    - `ReportingService`: Generates and saves Markdown/CSV reports.
    - `DatabaseService`: Used directly by the script for managing `AnalysisRun` records.
    - `cliUtils` / `displayUtils`: For parsing and displaying.
- **Refactoring Steps Taken (Summary):**
    1. Extracted core swap logic to `SwapAnalyzer`.
    2. Extracted core stats logic to `AdvancedStatsAnalyzer`.
    3. Created `HeliusSyncService` for data fetching/syncing.
    4. Created `PnlAnalysisService` for orchestrating analysis.
    5. Updated `ReportingService` and `report_utils.ts` for PNL reports.
    6. Refactored `helius-analyzer.ts` script to use these services and manage `AnalysisRun` persistence.

## Phase 4: API Layer Implementation (Largely Complete - pending Notes endpoint & full Behavior display)

**Goal:** Develop a robust API layer to expose analysis functionalities for client applications (e.g., dashboards), enable user tracking, and support scalable architecture. This phase transitions the system from script-driven to service-accessible.

### 4.1 API Design Principles & Technology

#### 4.1.1 Foundational Principles
- **RESTful Architecture:** Adhere to REST principles for resource naming, HTTP methods, and status codes.
- **Statelessness:** API endpoints will be stateless where possible, not relying on server-side session memory between requests.
- **Versioning:** API endpoints will be versioned (e.g., `/api/v1/...`) to allow for future iterations without breaking existing clients.
- **Consistent Error Handling:** Implement a standardized error response format.
- **Authentication:** Secure endpoints using API key-based authentication.

#### 4.1.2 API Technology Stack & Framework Selection
- **Context:** The backend is TypeScript-based, utilizing Prisma. The API layer should integrate seamlessly.
- **Recommendation:** A Node.js framework is highly recommended.
    - **NestJS:** An opinionated, TypeScript-first framework promoting robust architectural patterns (modules, services, controllers) that align well with the existing service-oriented structure. Provides strong out-of-the-box support for OpenAPI (Swagger) generation, validation, and more.

#### 4.1.3 API Documentation (OpenAPI/Swagger)
- **Requirement:** Implement automated generation of OpenAPI (Swagger) documentation from the outset. 
- **Benefits:** Provides a live, accurate API reference crucial for dashboard developers, simplifies development, testing, and future maintenance.
- **Implementation:** 
    - If NestJS is chosen, it has excellent built-in support.
    - For Fastify, libraries like `fastify-swagger` can be integrated.

- **Auto-generating client SDKs from routes**

#### 4.1.4 Configuration Management (API & Keys)
- **API Keys:**
    - Generation: Securely generate API keys for `User` models.
    - Storage: Store API keys hashed in the database (e.g., using `bcrypt`). The actual key is shown to the user once upon creation.
- **Application Configuration:**
    - Manage API application settings (database connection strings, logging levels, JWT secrets if used later) via environment variables (e.g., using a `.env` file with `dotenv` library), consistent with Prisma's `DATABASE_URL` handling.

### 4.2 Core API Components & User Tracking

#### 4.2.1 Database Schema for User Tracking (to be added to `prisma/schema.prisma`)
Two new models will be introduced:

```prisma
// In prisma/schema.prisma

model User {
  id           String    @id @default(cuid()) // Or use autoincrement Int
  apiKey       String    @unique // For API authentication
  description  String?   // e.g., "Dashboard Primary Access", "Analyst X"
  createdAt    DateTime  @default(now())
  lastSeenAt   DateTime?
  isActive     Boolean   @default(true)
  activityLogs ActivityLog[]
  // Optional: Link to user-specific settings or saved wallet lists
}

model ActivityLog {
  id                 String    @id @default(cuid()) // Or use autoincrement Int
  userId             String
  user               User      @relation(fields: [userId], references: [id])
  actionType         String    // e.g., 'get_wallet_summary', 'get_token_performance', 'run_pnl_analysis'
  timestamp          DateTime  @default(now())
  requestParameters  Json?     // Input parameters for the action
  status             String    // 'SUCCESS', 'FAILURE', 'INITIATED'
  durationMs         Int?      // Duration of the action
  errorMessage       String?
  sourceIp           String?   // Optional: for additional context

  @@index([userId])
  @@index([actionType])
  @@index([timestamp])
}
```

#### 4.2.2 Authentication
- Clients will include an `X-API-Key` header in requests.
- A middleware in the API framework will validate the API key against the `User` table and identify the `userId`.

#### 4.2.3 `DatabaseService` Enhancements (`src/services/database-service.ts`)
The existing `DatabaseService` will be augmented with methods to:
- Create and validate users/API keys.
- Record entries in the `ActivityLog` table (start, success, failure of actions).
- Update `lastSeenAt` for users.

### 4.3 API Endpoints (Illustrative)
All endpoints will be under a base path like `/api/v1/`.

#### 4.3.1 Wallet & General Information Endpoints
-   **`GET /wallets/{walletAddress}/summary`**: (Implemented)
    *   **Purpose:** Provides a comprehensive overview for a wallet, serving as the primary snapshot. It includes data for the "Sticky Summary Bar" and "General ACC Info" in a dashboard context. This endpoint also incorporates aggregated metrics previously envisioned for a separate `/aggregated-metrics` endpoint.
    *   **Data:** Wallet address, last active timestamp, days active (derived), key account-level performance indicators (e.g., latest PNL, token win rate from `AdvancedStatsResult`), a high-level behavior classification (from `BehaviorService`), and the full raw `AdvancedStatsResult` and `BehaviorMetrics` objects for clients needing more detail from this primary call.
    *   **Services Used:** `DatabaseService` (for `Wallet`, `AdvancedStatsResult`), `BehaviorService`.
    *   **Data Derivation Notes for "Last Active" and "Days Active":**
        *   **Wallet's "Last Active Timestamp":** Determined based on `Wallet.newestProcessedTimestamp` or the run timestamp from `AdvancedStatsResult`.
        *   **Wallet's "Days Active":** Calculated based on `Wallet.firstProcessedTimestamp` and the last active timestamp.
-   **`GET /wallets/{walletAddress}/info`**: (Potentially merged into summary or separate for more static details - currently merged into `/summary`)

#### Next Endpoints to Implement (Dashboard Focus - after immediate focus tasks):

1.  **`GET /wallets/{walletAddress}/token-performance`**: (Implemented - details below for completeness)
    *   **Plan Reference:** Section 4.3.2.
    *   **Purpose:** Powers the "aggregated data on token level" view for the dashboard.
    *   **Data:** Paginated and sortable list of token performance records from the latest `AnalysisResult` for the given wallet. Includes fields like `tokenAddress`, `netAmountChange`, `netSolProfitLoss`, etc.
    *   **Query Params:** `page`, `pageSize`, `sortBy`, `sortOrder`.
    *   **Services Used:** `DatabaseService`, `TokenPerformanceService`.

2.  **`GET /wallets/{walletAddress}/pnl-overview`**: (Implemented - details below for completeness)
    *   **Purpose:** Provide a detailed Profit and Loss (PNL) overview for a wallet, distinct from the general summary.
    *   **Data Considerations:** Includes overall realized PNL, total SOL spent/received, swap-level win rates, trade volumes, and various advanced trading statistics derived by `PnlAnalysisService` (e.g., median PNL per token, profit consistency, efficiency scores). This offers an in-depth financial performance view.
    *   **Services Used:** `PnlAnalysisService`.
    *   **Note:** This endpoint provides detailed financial metrics that are complementary to the broader `/summary` endpoint.

#### 4.3.2 Token Performance View Endpoints
-   **`GET /wallets/{walletAddress}/token-performance`**: (Implemented)
    *   **Purpose:** Powers the "aggregated data on token level" view for the dashboard.
    *   **Data:** Paginated and sortable list of token performance records from the latest `AnalysisResult` for the given wallet. Includes fields like `tokenAddress`, `netAmountChange`, `netSolProfitLoss`, etc.
    *   **Query Params:** `page`, `pageSize`, `sortBy`, `sortOrder`.
    *   **Services Used:** `DatabaseService` (via `TokenPerformanceService`).

#### 4.3.3 Aggregated Metrics View Endpoints
-   **`GET /wallets/{walletAddress}/aggregated-metrics`**: (Consolidated into `/summary`)
    *   **Status:** This endpoint's intended functionality (comprehensive metrics from `AdvancedStatsResult` and other overall statistics) is now provided as part of the `GET /wallets/{walletAddress}/summary` endpoint (see section 4.3.1). No separate endpoint is planned.
    *   **Services Used:** N/A (Functionality covered by `DatabaseService` as used by `/summary`).

#### 4.3.4 Behavior View Endpoints
-   **`GET /wallets/{walletAddress}/behavior-analysis`**: (Implemented, needs frontend display verification)
    *   **Purpose:** Powers the "behavior" view.
    *   **Data:** Structured output from `BehaviorService` including trader classification, pattern timelines, consistency metrics, efficiency scores, strategic tags, temporal behavior details. This will be more granular than the summary classification.
    *   **Services Used:** `BehaviorService`.

#### 4.3.5 Analysis Triggering Endpoints (Optional - for future dashboard control)
-   **Unified Trigger Pattern (Primary for Dashboard Interaction):**
    -   **`POST /analyses/wallets/{walletAddress}/trigger-analysis`**: (Future)
        *   **Purpose:** Allow the dashboard or other clients to initiate a new analysis (e.g., PNL & Stats, Behavior, or all relevant types) for a specific wallet, or to request a re-analysis of existing data. This endpoint enqueues the analysis task(s).
        *   **Request Body:** May include `analysisType: ('pnl' | 'behavior' | 'all')`, and type-specific configuration options (e.g., time range, parameters for `PnlAnalysisService` or `BehaviorService`). Could also include a flag like `forceRefetch: boolean` to control fetching of underlying transaction data.
        *   **Response:** `202 Accepted` with a `jobId` (e.g., `{ "jobId": "some-unique-identifier" }`).
        *   **Services Used:** An orchestrator service (or enhancements to `DatabaseService`) to create an `AnalysisJob` record (with status 'pending'), manage the workflow (e.g., fetching transactions if required, then running analyses), and add the job to a queue (see Phase 7 for Job Queue System).
    -   **`GET /analyses/jobs/{jobId}/status`**: (Future)
        *   **Purpose:** Allow the client to poll for the status of an analysis job initiated by `trigger-analysis`.
        *   **Response:** `{ "jobId": "...", "status": ("pending" | "running" | "completed" | "failed"), "progress": "...", "resultUrl": "..." (if completed, and if results aren't directly updating the main data store queried by GET display endpoints) }`.
        *   **Services Used:** `DatabaseService` (to query `AnalysisJob` status).
-   *(Note on other potential trigger endpoints: While older or separate systems might have individual, synchronous trigger endpoints like `POST /analyses/wallets/{walletAddress}/pnl`, these are **not** the primary mechanism for the dashboard. The dashboard should use the asynchronous Unified Trigger Pattern above to initiate analyses. The existing `GET` endpoints like `/pnl-overview`, `/behavior-analysis` are then used to display the results once the analysis job is complete).*

### 4.4 Service Layer Interaction
- API controllers/handlers (e.g., in `src/api/controllers/`) will:
    1. Perform request validation and parse parameters.
    2. Authenticate the request via API key, retrieve `userId`.
    3. Call `databaseService.logActivity()` at the start of the request, and then again for success/failure outcomes, capturing duration, request parameters, and `userId`.
    4. Instantiate and invoke the appropriate NestJS-wrapped service(s) from locations like `src/behavior/behavior.service.ts`, `src/database/database.service.ts`, etc.
    5. **Note on User Context in Services (Refinement of original Task 4 "Refactor Services for API User Context"):** 
        - Core underlying services (e.g., `OriginalBehaviorService` in `src/wallet_analysis/core/`) will generally remain agnostic to API `userId` and direct `logActivity` calls. This maintains their reusability for CLIs, workers, etc.
        - NestJS wrapper services (e.g., `src/behavior/behavior.service.ts`) that are directly called by API controllers will receive the `userId` if they orchestrate multiple distinct, significant sub-operations that require separate activity log entries beyond the main API call logging. For simple pass-through calls from the wrapper to an original service (like the current `BehaviorService.getWalletBehavior`), controller-level logging is sufficient.
        - The original services will not be modified to directly accept `userId` for logging purposes unless a compelling case arises for a specific service where internal steps are complex and directly relevant to user-initiated API actions.
    6. Format service responses for the API.

### 4.5 Pre-computation vs. On-the-fly API Calculation
- The API will primarily serve pre-calculated data stored by the analysis scripts/services (e.g., `AnalysisResult`, `AdvancedStatsResult`).
- Minor data transformations, filtering, or combining results from different service calls can occur in the API layer or services.
- Computationally intensive analysis will continue to be handled by the core analyzers and services, with results persisted to the database. The API can trigger these processes if `Analysis Triggering Endpoints` are implemented.

### 4.6 Relationship with Existing Scripts
- **Coexistence:** Existing scripts (e.g., `activityCorrelator.ts`, `helius-analyzer.ts`) can continue to operate for batch processing, scheduled tasks, or direct CLI use.
- **API for On-Demand:** The API layer primarily serves interactive, on-demand requests, typical of a dashboard interface.
- **Future Evolution:** Some script functionalities might eventually be triggerable via the API or refactored to use API endpoints for consistency, but this is not an immediate priority. The focus is on exposing read-heavy data and core analysis results via the API first.

## Phase 5: Dashboard Integration (Ongoing - Current Focus)

**Goal:** Develop a web-based dashboard that consumes the API layer to provide users with insights into wallet analysis data, focusing on intuitive UX, high-signal data presentation, and rapid insight extraction.

**Guiding Principles (from `docs/dash_details_thoughts.md`):**
- **Insight-Driven Design:** Every element should serve insight extraction, not just data presentation. Structure, labels, and navigation must accelerate pattern recognition and minimize friction.
- **Data Prioritization (Cognitive Flow Hierarchy):**
    - Top Left (Identity): Wallet address, balance, linked socials, active status (anchoring trust and relevance).
    - Top Right (Snapshot Metrics): P&L delta, winrate, behavior tag (e.g., "high-frequency sniper", "passive holder").
- **Metric Design (Insight Density):** Focus on ratio metrics and change metrics (e.g., winrate-to-volume ratio, profit consistency). Use clear visual cues (colors, icons) for trends.
- **Time Filter:** A single, master time filter affecting all dashboard panels, with sensible defaults and presets.
- **Behavioral Insight Presentation:** Use descriptive labels (e.g., "How Often This Wallet Acts") and comparative tags (e.g., "Faster than 82% of wallets").
- **UX Flow Optimization:** Collapsible sidebar, ubiquitous tooltips, hover-to-reveal context, and click-to-drilldown functionality.
- **Modular & Composable Components:** Prioritize data clarity and minimalism. Avoid visual clutter.

### 5.1 Dashboard Technology Stack & Architecture

-   **Framework:** Next.js (App Router)
-   **Styling:** TailwindCSS
-   **Core Component Library:** shadcn/ui (for primitives like tabs, buttons, dropdowns, cards, tables, date pickers)
-   **Metric Display & Layout Blocks:** Tremor (for clean metrics display, cards, grids, flex components)
-   **Charting:** Apache ECharts (for advanced/custom behavioral and temporal charts, e.g., heatmaps, bar ranges, session clusters) and mini sparkline charts (Tremor-compatible or simple ECharts) within metric cards.
    *   **Recommendation:** Develop a reusable `ChartWrapper` component or abstraction layer early (e.g., during Week 3). This wrapper should standardize common props (e.g., data, themes, loading states, error handling) and encapsulate ECharts instance setup and updates to reduce boilerplate, improve maintainability, and ensure consistency across different charts.
-   **Data Fetching:** SWR or React Query (for robust API integration, caching, and state synchronization).
    *   **Consideration for Data Schema Evolution:** Implement robust data handling strategies, including:
        *   Type guards for API response validation.
        *   Error boundaries at component and view levels.
        *   Graceful degradation or fallback UIs if expected data fields are missing or malformed, especially if the backend API schema is still evolving.
-   **State Management:** Zustand or React Context (for global state like selected wallet, time filter, and shared UI state; prefer lightweight options)

### 5.2 Dashboard Structure and API Mapping (based on user diagram and `dash_details_thoughts.md`)

-   **Sidebar (Collapsible):**
    *   Navigation: Wallet selection/repository, Wallet List, Settings, Documentation, Help/About.
    *   Implementation: shadcn/ui components.
-   **Main Window - Top Section (Sticky Summary Bar):**
    *   **Left Part: General Account Info:** Wallet address, balance, linked socials (if available).
        *   Data: Primarily from `GET /wallets/{walletAddress}/summary`.
    *   **Right Part: Account Summary Snapshot:** Last active date, P&L snapshot (e.g., 24h/7d change), key behavior profile/category tag.
        *   Data: Primarily from `GET /wallets/{walletAddress}/summary`.
    *   Implementation: Tremor `Card`, `Metric`, `Text`, `Flex`, `Grid` components.
-   **Universal Time Filter:**
    *   Placement: Prominently, e.g., top-right of the main content area or docked.
    *   Functionality: Affects all data views in the bottom section. Defaults (e.g., last 30 days) and presets (24h, 7d, 1m, YTD, All-Time, custom range).
    *   Implementation: shadcn/ui `Select` or `Dropdown` for presets, `DatePicker`!!! for custom ranges. Global state managed by Zustand/Context.
-   **Main Window - Bottom Section (Tabbed Data Views):**
    *   Container: `WalletTabsContainer` using shadcn/ui `Tabs` component.
    *   **Tab 1: Token Performance** (Formerly "Aggregated SPL Data" / "Aggregated Data")
        *   Purpose: Per-token level performance aggregation, including current holding status.
        *   Content: Sortable, paginated table or card list. Columns/fields: Token, P&L per token, trade count, average hold time, win rate per token, total volume, **current UI balance**.
        *   **Enhancement**: A filter will be added to show only tokens with a current balance > 0.
        *   API: `GET /wallets/{walletAddress}/token-performance` (with query params for pagination, sorting, time range). Data includes current balance fields from `AnalysisResult`.
        *   Implementation: shadcn/ui `Table`, Tremor `Card` (if card-based for each token).
    *   **Tab 2: Account Stats & PNL** (Formerly "Aggregated Metrics" / "P&L + Advanced Metrics")
        *   Purpose: Detailed account-level PNL and statistical metrics.
        *   Content: Overall PNL, win rates, average PNL/day, profit consistency index, advanced stats (e.g., trimmed mean PNL, standard deviation), trade volumes, median PNL per token.
        *   API: `GET /wallets/{walletAddress}/pnl-overview` and parts of `GET /wallets/{walletAddress}/summary`.
        *   Implementation: Tremor `Metric`, `Card`, `Grid`, ECharts for distributions if needed.
    *   **Tab 3: Behavioral Patterns** (Formerly "KPIs/Behavioral Metrics" / "Behavior Details")
        *   Purpose: Session-based behavior, activity heatmaps, winrate stratification.
        *   Content: Trader classification, pattern timelines, consistency metrics, efficiency scores, strategic tags, temporal behavior (e.g., activity heatmaps by hour/day, session length histograms, trades per session).
        *   API: `GET /wallets/{walletAddress}/behavior-analysis`.
        *   Implementation: ECharts for heatmaps, histograms, timelines. Tremor `Card` for displaying classifications and scores.
    *   **Tab 4: Reviewer Log / Notes** (Formerly "Notes")
        *   Purpose: Manual reviews, comments, and assessments by the analyst.
        *   Content: Editable rich text or markdown area.
        *   API: Custom endpoint for saving/loading notes per wallet (e.g., `POST /wallets/{walletAddress}/notes`, `GET /wallets/{walletAddress}/notes`).
        *   Implementation: shadcn/ui `Textarea` or a lightweight rich text editor. Debounce/autosave functionality.


### 5.3 Development Plan & Execution Steps (4-Week Iterative Cycle Example)

**Overarching Goals:**
-   API Layer First: Ensure necessary API endpoints from Phase 4 are stable and provide all data for a given view before starting its UI implementation.
-   Iterative Development: Build dashboard views one by one. Refine API based on frontend needs.
-   Component Reusability: Design modular components (e.g., `MetricCard`, `TimeRangeSelector`).

**Week 1: Project Setup & Layout Skeleton** - COMPLETE
*   **Tasks:**
    1.  Initialize Monorepo (if not already) or Frontend Project: Next.js with App Router. - COMPLETE
    2.  Integrate TailwindCSS. - COMPLETE
    3.  Configure shadcn/ui: Initialize, add necessary primitive components (buttons, tabs, dropdowns, cards, tables, date pickers). - COMPLETE
    4.  Integrate Tremor: Add to project for metric display components. - COMPLETE
    5.  Integrate Apache ECharts. - COMPLETE
    6.  Setup Data Fetching Library (SWR/React Query) and State Management (Zustand/Context). - COMPLETE
    7.  Define Routing: Main pages (`/wallets/[walletAddress]`, `/settings`, `/help`). - COMPLETE
    8.  Sidebar Implementation: Use shadcn/ui for structure and navigation items. - COMPLETE
    9.  Main Layout Skeleton (`WalletProfileLayout`):
        *   Top section: Placeholders for "General Account Info" (left) and "Account Summary Snapshot" (right). - COMPLETE
        *   Bottom section: Tab container (`WalletTabsContainer` with shadcn/ui `Tabs`) with stubs for the 4-5 data panels. - COMPLETE
        *   Use Tailwind grid/flex for responsive layout. - COMPLETE
    10. Component Stubs: `AccountSummaryCard`, `TimeRangeSelector`. - COMPLETE

**Week 2: Time Filter, Sticky Summary & "Token Performance" Tab** - COMPLETE
*   **Tasks:**
    1.  `TimeRangeSelector` Implementation:
        *   Build dropdown/date picker controls using shadcn/ui. - COMPLETE
        *   Store selected range globally using Zustand/Context. - COMPLETE
        *   Ensure API calls will use this global time range. - COMPLETE
    2.  Connect Sticky Summary Bar:
        *   Fetch data from `GET /wallets/{walletAddress}/summary` using SWR/React Query. - COMPLETE
        *   Populate "General Account Info" and "Account Summary Snapshot" using Tremor components. - COMPLETE
    3.  "Token Performance" Tab Implementation: - COMPLETE
        *   Create data fetching hook `useTokenPerformance(walletId, timeRange, page, pageSize, sortBy, sortOrder)` using SWR/React Query to call `GET /wallets/{walletAddress}/token-performance`.
        *   Display data in a shadcn/ui `Table` with pagination and sorting. - COMPLETE
        *   Include columns like Token, P&L, Trade Count, Avg Hold Time. - COMPLETE
    4.  Integrate basic loading states and error handling for API calls. - COMPLETE

**Week 3: "Account Stats & PNL" and "Behavioral Patterns" Tabs** - IN PROGRESS
*   **Tasks:**
    1.  "Account Stats & PNL" Tab Implementation: - COMPLETE
        *   Fetch data from `GET /wallets/{walletAddress}/pnl-overview` and parts of `GET /wallets/{walletAddress}/summary`. - COMPLETE
        *   Use Tremor `Metric`, `Card`, `Grid`, `Flex` to render key stats (Overall PNL, Winrate, Avg PNL/Day, Profit Consistency Index). - COMPLETE
        *   Incorporate ECharts for simple distributions if valuable (e.g., PNL distribution). - (Deferred)
    2.  "Behavioral Patterns" Tab Implementation: - IN PROGRESS
        *   Fetch data from `GET /wallets/{walletAddress}/behavior-analysis`. - COMPLETE (API connected)
        *   Display trader classification, strategic tags using Tremor `Text`, `Badge`. - LARGELY COMPLETE
        *   Implement ECharts for: - TO DO
            *   Activity Heatmap (e.g., trades by hour of day / day of week).
            *   Session Length Histogram.
            *   Pattern Timelines (if applicable from API data).
    3.  Ensure all tabs correctly respond to global `TimeRangeSelector` changes, re-fetching data as needed. - IN PROGRESS (Implemented for PNL and Token Performance, verify for Behavior)

**Week 4: "Reviewer Log/Notes" Tab, Polish & Export** - TO DO
*   **Tasks:**
    1.  "Reviewer Log/Notes" Tab Implementation:
        *   Implement `EditableNotes` component with a shadcn/ui `Textarea` or a simple rich text editor.
        *   Set up API endpoints (`GET`/`POST` `/wallets/{walletAddress}/notes`) and connect the component with debounced autosave.
    2.  (Optional) "Raw Transactions" Tab:
        *   If implementing, fetch data from a new `GET /wallets/{walletAddress}/transactions` endpoint.
        *   Display in a shadcn/ui `Table` with sorting, filtering, and pagination.
    3.  UX Polish:
        *   Add comprehensive tooltips (shadcn/ui `Tooltip`) for metrics and chart elements.
        *   Refine loading states (including indicators for ongoing analysis triggered by the user), empty states, and error states for all views and API interactions.
        *   Implement UI feedback mechanisms for asynchronous operations like analysis triggering (e.g., "Re-analyzing...", "Analysis complete/failed", progress indicators if available from `GET /analyses/jobs/{jobId}/status`).
        *   Thorough responsive testing, including dedicated mobile responsiveness testing and refinement for key views to ensure usability for on-the-go reviews (e.g., from shared links). - DO NOT FOCUS SO MUCH ON THIS FOR NOW
        *   Implement a default/fallback page if no wallet is selected or data is unavailable.
    4.  Export Options:
        *   Implement CSV export for "Token Performance" and "Raw Transactions" (if built) using `PapaParse`.
        *   (Optional) Implement PDF summary export for the "Sticky Summary Bar" or a condensed report using `jsPDF`.
    5.  Final review of component modularity and code clarity.

### 5.4 Future Enhancements (Post-Initial Build)
-   **Wallet Comparison View:** Ability to select two wallets and see their key metrics/tabs side-by-side.
-   **Leaderboards/Segment Comparison:** Compare selected wallet against predefined segments (e.g., top 10% PNL).
-   **Advanced Chart Interactions:** Drill-downs within charts, cross-filtering.
-   **User-Savable Views/Filters.**
-   **Integration with AI Assistant (Phase 6):** Expose dashboard data/queries to the LLM.

### 5.5 Relationship with Existing Scripts & API
- This dashboard exclusively consumes the API layer defined in Phase 4.
- No direct database access from the frontend.
- All computationally intensive analysis is performed by backend services, with results served via API.
- The dashboard **must** be able to trigger re-analysis for a wallet. This will use the unified analysis triggering endpoints (defined in 4.3.5: `POST /analyses/wallets/{walletAddress}/trigger-analysis` and `GET /analyses/jobs/{jobId}/status`). The UI must provide clear feedback to the user about the status of these background jobs. (PAY EXTRA ATTENTION TO THIS - WE NEED TO BE ABLE TO EXECUTE ANALYSIS, FETCHING AND RE-ANALYSIS)

## Phase 6: AI Assistant Integration (Experimental Pilot) >>> IMPORTANT: check before start working docs\behavioral_reconstruction_task.md

**Goal:** Explore and validate the value of an LLM-based AI assistant for natural language querying of analysis data and generating summaries, leveraging the established API layer.

**Trigger:** Core API endpoints are stable and initial dashboard views are functional, providing a clear understanding of available data and user interaction patterns.

**Prerequisites:**
- Stable API Layer (Phase 4 completed for core read endpoints).
- Well-defined data models and metrics (from Phases 1-3 and `prisma/schema.prisma`).
- Initial Dashboard implementation (Phase 5.1 and 5.2 underway) to inform valuable AI use cases.

**Recommended Timing:** Commence exploration during or after initial dashboard milestones (e.g., after Phase 5.2, when key dashboard views are connected to the API).

**Approach & Smart Choices:**
- **Tool-Based LLM Interaction:** Utilize a structured approach for LLM interaction, such as Anthropic's model context protocol or similar frameworks that allow defining tools for the LLM.
- **API as the Primary Tool Source:** Design LLM tools primarily as wrappers around the existing, validated API endpoints (developed in Phase 4).
    - *Example:* An LLM tool `getWalletPNLSummary(wallet_address: string)` would internally call the `GET /wallets/{walletAddress}/summary` API endpoint.
- **Focus on Read-Only Operations Initially:** Prioritize use cases like natural language querying and data summarization. Defer AI-driven actions (e.g., triggering new analyses) until read capabilities are mature and robust.
- **Isolate AI Components:** Develop AI integration as a distinct module or service to allow for independent iteration and experimentation without destabilizing core application logic or the primary dashboard.
- **Iterative Development & Prompt Engineering:** Treat as an experimental feature. Expect an iterative process of refining prompts, tools, and handling LLM responses.

**Potential Initial Use Cases:**
- Natural language queries for specific metrics: "What was wallet X's win rate last month?" or "Show me the PNL for SOL for wallet Y."
- Automated summaries of wallet behavior or performance based on available API data.
- Conversational exploration of data presented in the dashboard.

**Considerations for Technical Debt & Overhead:**
- **Avoid Direct Database Access by LLM:** Enforce LLM interaction via the API to maintain security, abstraction, and maintainability.
- **Start Small & Focused:** Begin with a few high-impact, low-complexity use cases to demonstrate value and refine the integration approach.
- **Human-in-the-Loop (HITL):** For complex queries or sensitive data synthesis, consider HITL mechanisms initially to validate AI outputs.

## Phase 7: Performance & Asynchronous Operations (Future Enhancement)

**Trigger:** API endpoints for triggering new analyses (see 4.3.5) become slow or block client requests for too long; need to process multiple analysis requests concurrently without overwhelming system resources.

**Smart Choices (aligned with `docs/scaling.md` Phase 2):

### 7.1 Job Queue System Introduction
- **Technology:** Introduce a job queue system (e.g., BullMQ) with Redis as the broker.
- **Purpose:** Offload long-running analysis tasks (PNL, Behavior, Correlation, Similarity) initiated via API calls to background workers.

### 7.2 API Integration with Job Queue
- API endpoints that trigger analyses (e.g., `POST /analyses/wallets/{walletAddress}/pnl`) will now:
    1. Validate the request and parameters.
    2. Add a job to the appropriate queue (e.g., `pnl-analysis-queue`).
    3. Return an immediate response (e.g., `202 Accepted` with a job ID).
- New API endpoints might be needed to check the status of a job (`GET /analyses/jobs/{jobId}`).

### 7.3 Worker Services Implementation
- Develop separate Node.js worker processes for each type of analysis or a generic worker that can handle different job types.
- Workers will listen to their respective queues.
- Upon receiving a job, a worker will:
    1. Instantiate and use the relevant services (`PnlAnalysisService`, `BehaviorService`, etc.) to perform the analysis.
    2. Update the job status in the queue and potentially in the `AnalysisRun` table in the database.
    3. Handle errors gracefully and update job status accordingly.

### 7.4 Benefits
- **Non-blocking API:** Improves API responsiveness for analysis-triggering requests.
- **Scalability:** Worker processes can be scaled independently based on load.
- **Resilience:** Jobs can be retried if workers fail (if queue is configured for retries).

## Phase 8: Advanced Database Scalability & Optimization (Future Enhancement)

**Trigger:** SQLite performance degrades significantly with a very large volume of transactions across many wallets; write contention becomes an issue; complex analytical queries for the dashboard become too slow despite optimizations.

**Smart Choices (aligned with `docs/scaling.md` Phase 4):

### 8.1 Database Migration to PostgreSQL
- **Action:** Use Prisma's migration capabilities to transition the database from SQLite to PostgreSQL.
- **Benefits:** PostgreSQL offers superior concurrency, scalability, robustness, and advanced features suitable for larger datasets and higher transaction volumes.
- **Impact:** Application code using Prisma Client will remain largely unchanged, demonstrating the power of the ORM.

### 8.2 Advanced Caching Layer
- **Technology:** Expand the use of Redis (introduced with job queues) or a similar caching solution.
- **Strategy:** Implement caching for frequently accessed, computationally expensive, or relatively static data:
    - Wallet summaries or frequently requested aggregated metrics from the API.
    - Results of common queries to `DatabaseService`.
- **Invalidation:** Develop a clear cache invalidation strategy to ensure data consistency.

### 8.3 Analytical Acceleration (If Required for Complex Dashboarding)
- **Context:** If dashboard queries remain slow even with PostgreSQL and caching, for highly complex, read-heavy analytics.
- **Options:**
    - **DuckDB:** For local or embedded analytics, potentially querying Parquet exports or a read replica of PostgreSQL.
    - **ETL + Data Warehouse (for very large scale):** Implement an ETL process to move data from PostgreSQL to a specialized analytical store (e.g., ClickHouse, BigQuery) if the application evolves into a large multi-user service requiring extensive BI capabilities. This is a significant architectural step and considered far-future.

## Implementation Order (Updated)

1.  Type Consolidation (Done)
2.  Core Analysis Extraction (Done)
3.  Utility Function Extraction (Done)
4.  Service Implementation (Refinement for user context may be needed) (Largely Done)
5.  Configuration Type Refactoring (Done)
6.  Script Transformation (Done)
    - `activityCorrelator.ts` (Done)
    - `wallet-behavior-analyzer.ts` (Done)
    - `kpi-comparison-report.ts` (Done)
    - `helius-analyzer.ts` (Done)
    - `walletSimilarity.ts` (Done)
7.  **Phase 4: API Layer Implementation (Largely Complete - pending Notes endpoint & full Behavior display)**
    *   7.1 Database schema changes for Users & ActivityLog. (Complete)
    *   7.2 `DatabaseService` enhancements for user/activity management. (Complete)
    *   7.3 API endpoint development (authentication, core read endpoints first, tech stack decision). (Largely Complete - `/summary`, `/token-performance`, `/pnl-overview` include balance data).
    *   7.4 Service modifications to accept user context for logging. (Ongoing as needed)
8.  **Phase 5: Dashboard Integration (Ongoing - Current Focus)**
    *   8.1 Dashboard skeleton and connection to summary API (including SOL/token balances). (Complete)
    *   8.2 Iterative implementation of dashboard views:
        *   "Token Performance" tab enhanced with current balances and filtering. (Complete)
        *   "Account Stats & PNL" tab. (Complete)
        *   "Behavioral Patterns" tab - Data connected, visualizations TO DO. (Current Focus)
        *   "Reviewer Log / Notes" tab. (TO DO)
    *   8.3 (Optional) Implementation of analysis triggering from dashboard. (Future)
9.  **Testing (Ongoing - See updated Testing Strategy)**
    *   9.1. Define test for the Mapper that will run periodically to detect changes in the logic of Helius!! 
10. **Phase 6: AI Assistant Integration (Experimental Pilot - NEW)**
    *   10.1 Define initial scope & use cases (e.g., natural language query for wallet summary).
    *   10.2 Design LLM tools based on existing API endpoints.
    *   10.3 Develop and test a pilot integration.
11. **Phase 7: Performance & Asynchronous Operations (Future Enhancement - formerly Phase 6)**
    *   11.1 Implement Job Queue System (e.g., BullMQ + Redis).
    *   11.2 Refactor API analysis triggers to use the job queue.
    *   11.3 Develop Worker Services.
12. **Phase 8: Advanced Database Scalability & Optimization (Future Enhancement - formerly Phase 7)**
    *   12.1 Migrate to PostgreSQL if SQLite limits are hit.
    *   12.2 Implement/Expand Caching Layer (Redis).
    *   12.3 Consider analytical acceleration tools if dashboarding complexity demands it.
13. (Further Future API Layer for Admin/Advanced Features)

## Testing Strategy (Updated)
