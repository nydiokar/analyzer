Recommendations for math improvement and user facing parts

My take (concise):
- Keep speed as primary driver, use balance as stabilizer, and add light consistency/volume gates to avoid noisy overfitting. The ruleset stays readable and deterministic, so product can explain ‚Äúwhy‚Äù. All proposals below are additive and low-risk; they won‚Äôt break existing outputs but will improve ranking stability and label quality.

Behavioral core: inputs

Required fields per wallet window:

From BehaviorAnalyzer: totalBuyCount, totalSellCount, completePairsCount, averageFlipDurationHours, medianHoldTime, buySellSymmetry, sequenceConsistency, percentTradesUnder1Hour, percentTradesUnder4Hours, sessionCount, avgTradesPerSession, tradingTimeDistribution, reentryRate, percentageOfUnpairedTokens, riskMetrics.averageTransactionValueSol, riskMetrics.largestTransactionValueSol, uniqueTokensTraded, totalTradeCount.

Promote now: flipDurationStandardDeviation, tradeValueStandardDeviationSol, activeTradingPeriods.activityFocusScore (or entropy).

Normalizations

Clamp rates to [0,1].

Speed score:
speed = 0.6 * pct<1h + 0.4 * pct<4h, where pct<1h = percentTradesUnder1Hour/100, pct<4h = percentTradesUnder4Hours/100.

Why: Center flipper identity on short-horizon flips. Using two windows makes it robust to sampling noise while keeping the signal intuitive.

Balance score:
balance = 0.5 * buySellSymmetry + 0.5 * sequenceConsistency (both already 0‚Äì1 by definition).

Why: Symmetry prevents one-sided farming from looking like flipping; sequence consistency rewards completed buy‚Üísell cycles.

Consistency penalties (lower is worse):
time_var = min(1, 1 / (1 + flipDurationStandardDeviation/œÑh)) with œÑh=4.
size_var = min(1, 1 / (1 + (tradeValueStandardDeviationSol / max(1e-9, riskMetrics.averageTransactionValueSol)))).

Why: Penalize erratic timing/sizing without letting variance dominate the core identity. The reciprocal form softly down-weights outliers and is easy to explain.

Activity floor:
activity = min(1, totalTradeCount / Nmin) with Nmin=30.

Why: Prevents small-sample noise from scoring too high; scales up naturally as evidence accumulates.

FlipperScore (explicit)
base = 0.65*speed + 0.35*balance
boost_ultrafast = 0.2 if tradingTimeDistribution['<30m'] >= 0.5 else 0
consistency = 0.5*time_var + 0.5*size_var
FlipperScore = clamp01( (base + boost_ultrafast) * (0.85 + 0.15*consistency) * activity )


Interpretation: speed dominates, balance refines, ultra-fast bonus is gated, variability tempers, low activity caps impact. Matches your intent; fully deterministic.

Risk: If a user has bursty <30m activity, the boost can overshoot; the consistency multiplier counteracts this by weighting regularity.

Secondary scalars for sorting and explainability

Sizing CV: size_cv = tradeValueStandardDeviationSol / max(1e-9, riskMetrics.averageTransactionValueSol).

Timing CV proxy: time_cv = flipDurationStandardDeviation / max(1e-9, medianHoldTime).

Session regularity: use 1 - entropy_norm(hourlyTradeCounts) or your activityFocusScore. Expose one scalar ‚ÄúRegularityScore‚Äù in [0,1].

Labels (rule set, minimal and legible)

Evaluate in order; first hit wins.

True Flipper: FlipperScore ‚â• 0.75 AND percentTradesUnder1Hour ‚â• 60 AND buySellSymmetry ‚â• 0.6 AND sequenceConsistency ‚â• 0.6.

Fast Trader: FlipperScore ‚â• 0.5 AND percentTradesUnder1Hour ‚â• 40 AND sequenceConsistency ‚â• 0.5.

Accumulator: totalBuyCount ‚â• 2*totalSellCount AND sequenceConsistency < 0.5.

Distributor: totalSellCount ‚â• 2*totalBuyCount AND sequenceConsistency < 0.5.

Swing/Position: percentTradesUnder4Hours < 40 OR medianHoldTime ‚â• 24.

Low Activity: totalTradeCount < 15 OR completePairsCount < 5.

Why these: Each label is tied to a small, human-checkable set of conditions. This keeps explanations crisp (good for UI ‚ÄúWhy‚Äù drawer) and makes QA straightforward.

Confidence score
evidence = weighted hits across rules:
  w = {
    speed: (percentTradesUnder1Hour/100),         // up to 1
    balance: balance,                              // 0‚Äì1
    pairs: min(1, completePairsCount/20),
    activity: activity,                            // 0‚Äì1
    consistency: consistency                       // 0‚Äì1
  }
Confidence = clamp01(0.25*w.speed + 0.2*w.balance + 0.2*w.pairs + 0.2*w.activity + 0.15*w.consistency)

Why: Confidence reflects both strength (speed/balance) and evidence (pairs/activity), with a mild boost for low variance (consistency). Tunable weights but sensible defaults.


Penalty: if quality_flags present (price_gap | decimals_unknown | spam_airdrop_heavy), multiply by 0.8 per flag (min 0.4).

Why: Quality flags are orthogonal to behavior but protect rankings and labels from data defects. A soft multiplicative penalty is reversible once data improves.

Data-quality flags (hard gates and UI badges)

price_gap, decimals_unknown, token_migration_detected, spam_airdrop_heavy, insufficient_pairs, clock_skew_timestamps.

If insufficient_pairs, force label Low Activity.

Show flags inline and exclude flagged wallets from leaderboards by default.

Why: Surfaces caveats to users and keeps leaderboards trustworthy without hiding data.

Outputs (API contract, compact)
{
  wallet, window, analyzerVersion,
  flipperScore: number,
  tradingStyle: "True Flipper"|"Fast Trader"|"Accumulator"|"Distributor"|"Swing/Position"|"Low Activity",
  confidenceScore: number,
  drivers: {
    percentTradesUnder1Hour, percentTradesUnder4Hours,
    buySellSymmetry, sequenceConsistency,
    averageFlipDurationHours, medianHoldTime,
    flipDurationStandardDeviation, tradeValueStandardDeviationSol,
    size_cv, time_cv, RegularityScore,
    reentryRate, percentageOfUnpairedTokens,
    sessionCount, avgTradesPerSession
  },
  activity: { totalTradeCount, completePairsCount, uniqueTokensTraded },
  quality_flags: string[]
}


All driver fields already exist or are the promoted additions.

Status:
- Now: implement flipDurationStandardDeviation, tradeValueStandardDeviationSol, RegularityScore, validations, and drivers block.
- Next: add feature flag, backfill, and verify determinism on sampled sets.

Validation checks (must pass before persisting)

totalTradeCount = totalBuyCount + totalSellCount

completePairsCount ‚â§ min(totalBuyCount, totalSellCount)

0 ‚â§ percentTradesUnder1Hour ‚â§ 100 and same for <4h

0 ‚â§ buySellSymmetry, sequenceConsistency ‚â§ 1

If medianHoldTime = 0, set time_cv = 0 to avoid blow-up

Determinism: same inputs ‚áí identical outputs (hash with analyzerVersion).

UX presentation

One card: tradingStyle, FlipperScore, confidenceScore.

Three micro-bars under it: Speed, Balance, Consistency.

Chips: Ultra-fast %, Symmetry, Pairs, Regularity.

Flags row if any.

Small ‚ÄúWhy‚Äù drawer: list the exact rule that fired with driver values.

Cross-wallet comparison fields

Sort by FlipperScore. Secondary: RegularityScore then size_cv ascending.

Filters: min totalTradeCount, exclude flags.

Cluster later; initial leaderboard uses these scalars only.

Developer route map

Add two metrics in BehaviorAnalyzer: flipDurationStandardDeviation, tradeValueStandardDeviationSol; compute alongside existing distributions.

Compute size_cv, time_cv, RegularityScore in-place; no extra passes.

Implement rule eval as a pure function over the output struct; unit-test with fixtures.

Persist analyzerVersion and quality_flags.

Add invariant unit tests for the validation checks above.

Ship behind a feature flag; backfill last 30 days; verify determinism on a sample set.






### Compact master list (no explanations)

#### PNL per-token (SwapAnalyzer ‚Üí OnChainAnalysisResult)
- tokenAddress, totalAmountIn, totalAmountOut, netAmountChange
- totalSolSpent, totalSolReceived, totalFeesPaidInSol
- netSolProfitLoss
- transferCountIn, transferCountOut
- firstTransferTimestamp, lastTransferTimestamp
- isValuePreservation, preservationType, estimatedPreservedValue
- currentUiBalance, currentUiBalanceString, balanceDecimals, balanceFetchedAt

#### PNL summary (PnlAnalysisService ‚Üí SwapAnalysisSummary)
- totalVolume, totalFees, realizedPnl, unrealizedPnl, netPnl
- stablecoinNetFlow
- totalSignaturesProcessed
- profitableTokensCount, unprofitableTokensCount
- averageSwapSize
- totalExecutedSwapsCount
- averageRealizedPnlPerExecutedSwap
- realizedPnlToTotalVolumeRatio
- firstTransactionTimestamp, lastTransactionTimestamp
- overallFirstTimestamp, overallLastTimestamp
- currentSolBalance, balancesFetchedAt, tokenBalances

#### Advanced stats (AdvancedStatsAnalyzer ‚Üí AdvancedTradeStats)
- medianPnlPerToken, trimmedMeanPnlPerToken
- tokenWinRatePercent
- standardDeviationPnl
- medianPnlToVolatilityRatio
- weightedEfficiencyScore
- averagePnlPerDayActiveApprox
- firstTransactionTimestamp (adv), lastTransactionTimestamp (adv)

#### PNL overview (PnlOverviewService ‚Üí PnlOverviewResponseData)
- swapWinRate, avgPLTrade
- totalSolSpent, totalSolReceived

#### Behavior analysis (BehaviorAnalyzer ‚Üí BehavioralMetrics)
- Flipper: buySellRatio, buySellSymmetry, averageFlipDurationHours, medianHoldTime, sequenceConsistency, flipperScore
- Activity: uniqueTokensTraded, tokensWithBothBuyAndSell, tokensWithOnlyBuys, tokensWithOnlySells, totalTradeCount, totalBuyCount, totalSellCount, completePairsCount, averageTradesPerToken
- Time distribution: tradingTimeDistribution, percentTradesUnder1Hour, percentTradesUnder4Hours
- Sessions: sessionCount, avgTradesPerSession, activeTradingPeriods, averageSessionStartHour, averageSessionDurationMinutes
- Preferences/Risk: tokenPreferences.mostTradedTokens, riskMetrics.averageTransactionValueSol, riskMetrics.largestTransactionValueSol
- Holding posture: averageCurrentHoldingDurationHours, medianCurrentHoldingDurationHours, weightedAverageHoldingDurationHours, percentOfValueInCurrentHoldings
- Classification: tradingStyle, confidenceScore
- Timestamps: firstTransactionTimestamp, lastTransactionTimestamp
- Reentry/Unpaired: reentryRate, percentageOfUnpairedTokens

---

### Holding Time Methodology (Predictive Risk Model)

#### Problem Statement
Traditional holding time calculations face challenges with asymmetric trading patterns (e.g., buy 200k tokens, gradually sell 45% over multiple events, still hold 55%). The question becomes: "Is this wallet a holder or a trader?" and more importantly for predictive use cases: "When will they exit their current position?"

#### Solution: Two-Layer Approach

**Layer 1: Historical Pattern Calculation (Weighted Average - Option B)**
- Calculate holding time ONLY from completed historical positions (exclude current holdings)
- Use FIFO-based weighted average across all sold portions
- Formula: `Œ£(amount_i √ó duration_i) / total_amount` for tokens where position dropped below exit threshold
- Exit threshold: 20% of peak position (configurable via `config.exitThreshold`)
- Dust threshold: 5% of peak position (ignore residual amounts via `config.dustThreshold`)

**Layer 2: Predictive Risk Model (Option D)**
- Compare historical pattern to current position age
- Calculate time remaining: `max(0, historicalAverage - currentPositionAge)`
- Assign risk levels based on estimated time until exit
- Enable forward-looking "dump risk" analysis for token holders

#### Position Lifecycle States

```typescript
enum PositionStatus {
  ACTIVE,    // >20% of peak still held ‚Üí position ongoing
  EXITED,    // <20% of peak remaining ‚Üí position closed
  DUST       // <5% remaining ‚Üí ignored
}

enum BehaviorType {
  FULL_HOLDER,     // >75% of peak still held
  PROFIT_TAKER,    // 25-75% of peak still held
  MOSTLY_EXITED    // 10-25% remaining
}
```

#### Key Metrics

**Per-Token Historical:**
- `historicalAverageHoldTime`: Weighted average from completed cycles only (hours)
- `exitPattern`: 'GRADUAL' | 'ALL_AT_ONCE' (based on sell distribution)
- `completedCycleCount`: Number of tokens fully exited in history

**Current Position (for target token):**
- `currentPositionAge`: Time since first buy of this token (hours)
- `percentAlreadySold`: % of peak position sold
- `positionStatus`: ACTIVE | EXITED | DUST
- `behaviorType`: Classification of current holding pattern

**Predictive:**
- `estimatedTimeUntilExit`: `historicalAverage - currentPositionAge` (hours)
- `riskLevel`: 'CRITICAL' (<1 day) | 'HIGH' (<2 days) | 'MEDIUM' (<5 days) | 'LOW' (5+ days)

#### Implementation Notes

**Peak Position Calculation:**
```typescript
// Track maximum tokens ever held via FIFO simulation
peakPosition = max(running_balance) across all trades
```

**Exit Detection:**
```typescript
// Position considered "exited" when drops below threshold
if (currentPosition / peakPosition < exitThreshold) {
  exitTime = timestamp_crossed_threshold
  cycleDuration = exitTime - entryTime
}
```

**Weighted Average (Historical Only):**
```typescript
// For each COMPLETED token (where position exited)
tokenHours = Œ£(sellAmount_i √ó holdDuration_i) / totalBought

// Aggregate across all completed tokens
historicalAverage = Œ£(tokenHours_j) / completedTokenCount
```

**Current Position Classification:**
```typescript
percentRemaining = currentPosition / peakPosition

if (percentRemaining < 0.05) ‚Üí DUST (filter out)
else if (percentRemaining < 0.20) ‚Üí EXITED (use exit timestamp)
else if (percentRemaining > 0.75) ‚Üí FULL_HOLDER (still active)
else ‚Üí PROFIT_TAKER (still active, taking profits)
```

**Weighted Average Entry Time (Multiple Buys):**
```typescript
// When wallet has multiple buys: 100k day 1, 50k day 3, 30k day 5
// Calculate weighted average entry time to match weighted sell logic

weightedEntryTime = Œ£(amount_i √ó timestamp_i) / Œ£(amount_i)
// Example: (100k√óday1 + 50k√óday3 + 30k√óday5) / 180k = day 2.11

currentPositionAge = NOW - weightedEntryTime
```

#### Use Case: Token Holder Risk Analysis

**Scenario:** Trader wants to buy $TOKEN and checks top 10 holders

**Per Holder Display:**
```
Holder #1 (15% supply) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ üî¥ HIGH RISK
  Historical avg: 5 days
  Current position: Day 3 (45% sold)
  Est. exit: ~2 days
  Type: Profit Taker
```

**Aggregate Token Risk:**
```
‚Ä¢ 27% of supply: üî¥ HIGH RISK (exit <48h)
‚Ä¢ 18% of supply: üü° MEDIUM RISK (exit 3-7d)
‚Ä¢ 55% of supply: üü¢ LOW RISK (7+ days)

Recommendation: High dump risk within 48h
```

#### Why This Approach

**Mathematically Honest:**
- Weighted average accounts for all trading activity proportionally
- No arbitrary "holding vs trading" cutoffs for metric calculation
- Preserves precision across different selling patterns

**Behaviorally Useful:**
- Position states capture trader intent (holder vs profit-taker)
- Historical-only calculation enables clean prediction
- Current position tracking shows real-time risk

**Predictive Power:**
- Separating history from current state enables time-to-exit estimation
- Risk levels provide actionable insights for trading decisions
- Aggregated holder analysis predicts token-level "lifespan"

#### Configuration

```typescript
interface HoldingThresholds {
  exitThreshold: number;              // 0.20 (20% remaining = exited, 80% sold)
  dustThreshold: number;               // 0.05 (5% remaining = dust, ignore completely)
  minimumSolValue: number;             // 0.001 SOL minimum to count
  minimumHoldingTimeSeconds: number;   // 60s minimum duration
  minimumCompletedCycles: number;      // 3 completed tokens for reliable pattern
}

interface RiskThresholds {
  criticalHours: number;  // 24 (<1 day)
  highHours: number;      // 48 (<2 days)
  mediumHours: number;    // 120 (<5 days)
  // ‚â•120 hours (5+ days) = LOW
}

interface TimeWindowOptions {
  last7Days: boolean;     // Show pattern from last 7 days
  last30Days: boolean;    // Show pattern from last 30 days
  allTime: boolean;       // Show pattern from last 90 days (or all data)
}
```

---

### Derivations and where they‚Äôre calculated (brief ‚Äúmath‚Äù)

#### PNL per-token (SwapAnalyzer)
- netAmountChange = totalAmountIn ‚àí totalAmountOut
- netSolProfitLoss = totalSolReceived ‚àí totalSolSpent ‚àí totalFeesPaidInSol
- estimatedPreservedValue = current SOL value of net stablecoin holdings (stablecoins only)
- transferCountIn/Out: counts of buy/sell transfers per token
- first/lastTransferTimestamp: min/max over that token‚Äôs trades

#### PNL summary (PnlAnalysisService)
- totalVolume = Œ£ per-token (totalSolSpent + totalSolReceived)
- totalFees = Œ£ per-token totalFeesPaidInSol
- realizedPnl = Œ£ per-token netSolProfitLoss for non-stablecoins
- unrealizedPnl = Œ£ per-token estimatedPreservedValue for stablecoins
- netPnl = realizedPnl + unrealizedPnl
- stablecoinNetFlow: net SOL flow into/out of stablecoins
- totalSignaturesProcessed: distinct signatures considered in analysis
- profitableTokensCount = count(non-stablecoin tokens with netSolProfitLoss > 0)
- unprofitableTokensCount = count(non-stablecoin tokens with netSolProfitLoss < 0)
- averageSwapSize = totalVolume / (profitableTokensCount + unprofitableTokensCount)
- totalExecutedSwapsCount = Œ£ over non-stablecoins (transferCountIn + transferCountOut)
- averageRealizedPnlPerExecutedSwap = realizedPnl / totalExecutedSwapsCount (guard 0)
- realizedPnlToTotalVolumeRatio = realizedPnl / totalVolume (guard 0)
- firstTransactionTimestamp / lastTransactionTimestamp: summary-level min/max over inputs
- overallFirstTimestamp / overallLastTimestamp: min/max over all input swap records (explicitly broadest window)
- currentSolBalance, balancesFetchedAt, tokenBalances: from WalletBalanceService snapshot

#### Advanced stats (AdvancedStatsAnalyzer; typically non-stablecoins subset)
- medianPnlPerToken = median over token PNLs where PNL ‚â† 0
- trimmedMeanPnlPerToken = mean after trimming extremes
- tokenWinRatePercent = 100 √ó (# tokens with PNL > WIN_THRESHOLD_SOL) / (# tokens with PNL ‚â† 0)
- standardDeviationPnl = sample std dev over token PNLs
- medianPnlToVolatilityRatio = medianPnlPerToken / standardDeviationPnl (guard 0)
- weightedEfficiencyScore = custom function(avg PNL, win rate) with linear win rate impact
- averagePnlPerDayActiveApprox = PNL per token scaled by active span and averaged
- first/lastTransactionTimestamp (adv): min/max over analyzer input trades

#### PNL overview derivatives (PnlOverviewService)
- swapWinRate:
  - If individual-trade data present: (profitableTradeCount / totalIndividualTrades) √ó 100
  - Else: token-level proxy (profitableTokensCount / (profitable + unprofitable)) √ó 100
- avgPLTrade = realizedPnl / totalTrades (token-level fallback when needed)
- totalSolSpent = Œ£ per-token totalSolSpent
- totalSolReceived = Œ£ per-token totalSolReceived

#### Behavior analysis (BehaviorAnalyzer)
- Flipper metrics:
  - buySellRatio = totalBuyCount / totalSellCount (guard 0)
  - buySellSymmetry: average per-token symmetry for tokens with both sides
  - averageFlipDurationHours: mean buy‚Üísell time across completed pairs
  - medianHoldTime: median of flip durations
  - sequenceConsistency: average (completed pairs / max possible pairs) per token
  - flipperScore: composite score (no overall ratio penalty)
- Activity:
  - uniqueTokensTraded: distinct mints
  - tokensWithBothBuyAndSell: tokens with ‚â•1 buy and ‚â•1 sell
  - tokensWithOnlyBuys, tokensWithOnlySells: counts by side-only
  - totalTradeCount = totalBuyCount + totalSellCount
  - averageTradesPerToken = totalTradeCount / uniqueTokensTraded (guard 0)
  - completePairsCount: total number of completed buy‚Üísell pairs
- Time distribution:
  - tradingTimeDistribution: histogram of flip durations across buckets
  - percentTradesUnder1Hour/4Hours: share of flips in thresholds
- Sessions:
  - sessionCount: count of sequences where inter-trade gap ‚â§ threshold (e.g., 60m)
  - avgTradesPerSession = totalTradeCount / sessionCount (guard 0)
  - activeTradingPeriods:
    - hourlyTradeCounts: counts by UTC hour
    - identifiedWindows: adaptive thresholded consecutive hour windows
    - activityFocusScore: concentration measure (e.g., share in windows)
  - averageSessionStartHour: circular mean of session starts
  - averageSessionDurationMinutes: mean session length
- Preferences/Risk:
  - tokenPreferences.mostTradedTokens: top-N by (buy+sell) counts
  - riskMetrics.averageTransactionValueSol = Œ£ associatedSolValue / totalTradeCount (guard 0)
  - riskMetrics.largestTransactionValueSol = max associatedSolValue
- Holding posture:
  - average/median/weightedAverageCurrentHoldingDurationHours: stats over open positions; weighted by size for weighted average
  - percentOfValueInCurrentHoldings = 100 √ó (value of current holdings / total portfolio value) (guard 0)
- Classification:
  - tradingStyle, confidenceScore: derived from behavioral signals
- Timestamps:
  - first/lastTransactionTimestamp: min/max over input swaps
- Reentry/Unpaired:
  - reentryRate = tokensWithMultipleCycles / tokensWithBothBuyAndSell (guard 0)
  - percentageOfUnpairedTokens = 100 √ó ((uniqueTokensTraded ‚àí tokensWithBothBuyAndSell) / uniqueTokensTraded) (guard 0)