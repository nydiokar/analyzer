Recommendations for math improvement and user facing parts

My take (concise):
- Keep speed as primary driver, use balance as stabilizer, and add light consistency/volume gates to avoid noisy overfitting. The ruleset stays readable and deterministic, so product can explain “why”. All proposals below are additive and low-risk; they won’t break existing outputs but will improve ranking stability and label quality.

Behavioral core: inputs

Required fields per wallet window:

From BehaviorAnalyzer: totalBuyCount, totalSellCount, completePairsCount, averageFlipDurationHours, medianHoldTime, buySellSymmetry, sequenceConsistency, percentTradesUnder1Hour, percentTradesUnder4Hours, sessionCount, avgTradesPerSession, tradingTimeDistribution, reentryRate, percentageOfUnpairedTokens, riskMetrics.averageTransactionValueSol, riskMetrics.largestTransactionValueSol, uniqueTokensTraded, totalTradeCount.

Promote now: flipDurationStandardDeviation, tradeValueStandardDeviationSol, activeTradingPeriods.activityFocusScore (or entropy).

Normalizations

Clamp rates to [0,1].

Speed score:
speed = 0.6 * pct<1h + 0.4 * pct<4h, where pct<1h = percentTradesUnder1Hour/100, pct<4h = percentTradesUnder4Hours/100.

Why: Center flipper identity on short-horizon flips. Using two windows makes it robust to sampling noise while keeping the signal intuitive.

Balance score:
balance = 0.5 * buySellSymmetry + 0.5 * sequenceConsistency (both already 0–1 by definition).

Why: Symmetry prevents one-sided farming from looking like flipping; sequence consistency rewards completed buy→sell cycles.

Consistency penalties (lower is worse):
time_var = min(1, 1 / (1 + flipDurationStandardDeviation/τh)) with τh=4.
size_var = min(1, 1 / (1 + (tradeValueStandardDeviationSol / max(1e-9, riskMetrics.averageTransactionValueSol)))).

Why: Penalize erratic timing/sizing without letting variance dominate the core identity. The reciprocal form softly down-weights outliers and is easy to explain.

Activity floor:
activity = min(1, totalTradeCount / Nmin) with Nmin=30.

Why: Prevents small-sample noise from scoring too high; scales up naturally as evidence accumulates.

FlipperScore (explicit)
base = 0.65*speed + 0.35*balance
boost_ultrafast = 0.2 if tradingTimeDistribution['<30m'] >= 0.5 else 0
consistency = 0.5*time_var + 0.5*size_var
FlipperScore = clamp01( (base + boost_ultrafast) * (0.85 + 0.15*consistency) * activity )


Interpretation: speed dominates, balance refines, ultra-fast bonus is gated, variability tempers, low activity caps impact. Matches your intent; fully deterministic.

Risk: If a user has bursty <30m activity, the boost can overshoot; the consistency multiplier counteracts this by weighting regularity.

Secondary scalars for sorting and explainability

Sizing CV: size_cv = tradeValueStandardDeviationSol / max(1e-9, riskMetrics.averageTransactionValueSol).

Timing CV proxy: time_cv = flipDurationStandardDeviation / max(1e-9, medianHoldTime).

Session regularity: use 1 - entropy_norm(hourlyTradeCounts) or your activityFocusScore. Expose one scalar “RegularityScore” in [0,1].

Labels (rule set, minimal and legible)

Evaluate in order; first hit wins.

True Flipper: FlipperScore ≥ 0.75 AND percentTradesUnder1Hour ≥ 60 AND buySellSymmetry ≥ 0.6 AND sequenceConsistency ≥ 0.6.

Fast Trader: FlipperScore ≥ 0.5 AND percentTradesUnder1Hour ≥ 40 AND sequenceConsistency ≥ 0.5.

Accumulator: totalBuyCount ≥ 2*totalSellCount AND sequenceConsistency < 0.5.

Distributor: totalSellCount ≥ 2*totalBuyCount AND sequenceConsistency < 0.5.

Swing/Position: percentTradesUnder4Hours < 40 OR medianHoldTime ≥ 24.

Low Activity: totalTradeCount < 15 OR completePairsCount < 5.

Why these: Each label is tied to a small, human-checkable set of conditions. This keeps explanations crisp (good for UI “Why” drawer) and makes QA straightforward.

Confidence score
evidence = weighted hits across rules:
  w = {
    speed: (percentTradesUnder1Hour/100),         // up to 1
    balance: balance,                              // 0–1
    pairs: min(1, completePairsCount/20),
    activity: activity,                            // 0–1
    consistency: consistency                       // 0–1
  }
Confidence = clamp01(0.25*w.speed + 0.2*w.balance + 0.2*w.pairs + 0.2*w.activity + 0.15*w.consistency)

Why: Confidence reflects both strength (speed/balance) and evidence (pairs/activity), with a mild boost for low variance (consistency). Tunable weights but sensible defaults.


Penalty: if quality_flags present (price_gap | decimals_unknown | spam_airdrop_heavy), multiply by 0.8 per flag (min 0.4).

Why: Quality flags are orthogonal to behavior but protect rankings and labels from data defects. A soft multiplicative penalty is reversible once data improves.

Data-quality flags (hard gates and UI badges)

price_gap, decimals_unknown, token_migration_detected, spam_airdrop_heavy, insufficient_pairs, clock_skew_timestamps.

If insufficient_pairs, force label Low Activity.

Show flags inline and exclude flagged wallets from leaderboards by default.

Why: Surfaces caveats to users and keeps leaderboards trustworthy without hiding data.

Outputs (API contract, compact)
{
  wallet, window, analyzerVersion,
  flipperScore: number,
  tradingStyle: "True Flipper"|"Fast Trader"|"Accumulator"|"Distributor"|"Swing/Position"|"Low Activity",
  confidenceScore: number,
  drivers: {
    percentTradesUnder1Hour, percentTradesUnder4Hours,
    buySellSymmetry, sequenceConsistency,
    averageFlipDurationHours, medianHoldTime,
    flipDurationStandardDeviation, tradeValueStandardDeviationSol,
    size_cv, time_cv, RegularityScore,
    reentryRate, percentageOfUnpairedTokens,
    sessionCount, avgTradesPerSession
  },
  activity: { totalTradeCount, completePairsCount, uniqueTokensTraded },
  quality_flags: string[]
}


All driver fields already exist or are the promoted additions.

Status:
- Now: implement flipDurationStandardDeviation, tradeValueStandardDeviationSol, RegularityScore, validations, and drivers block.
- Next: add feature flag, backfill, and verify determinism on sampled sets.

Validation checks (must pass before persisting)

totalTradeCount = totalBuyCount + totalSellCount

completePairsCount ≤ min(totalBuyCount, totalSellCount)

0 ≤ percentTradesUnder1Hour ≤ 100 and same for <4h

0 ≤ buySellSymmetry, sequenceConsistency ≤ 1

If medianHoldTime = 0, set time_cv = 0 to avoid blow-up

Determinism: same inputs ⇒ identical outputs (hash with analyzerVersion).

UX presentation

One card: tradingStyle, FlipperScore, confidenceScore.

Three micro-bars under it: Speed, Balance, Consistency.

Chips: Ultra-fast %, Symmetry, Pairs, Regularity.

Flags row if any.

Small “Why” drawer: list the exact rule that fired with driver values.

Cross-wallet comparison fields

Sort by FlipperScore. Secondary: RegularityScore then size_cv ascending.

Filters: min totalTradeCount, exclude flags.

Cluster later; initial leaderboard uses these scalars only.

Developer route map

Add two metrics in BehaviorAnalyzer: flipDurationStandardDeviation, tradeValueStandardDeviationSol; compute alongside existing distributions.

Compute size_cv, time_cv, RegularityScore in-place; no extra passes.

Implement rule eval as a pure function over the output struct; unit-test with fixtures.

Persist analyzerVersion and quality_flags.

Add invariant unit tests for the validation checks above.

Ship behind a feature flag; backfill last 30 days; verify determinism on a sample set.






### Compact master list (no explanations)

#### PNL per-token (SwapAnalyzer → OnChainAnalysisResult)
- tokenAddress, totalAmountIn, totalAmountOut, netAmountChange
- totalSolSpent, totalSolReceived, totalFeesPaidInSol
- netSolProfitLoss
- transferCountIn, transferCountOut
- firstTransferTimestamp, lastTransferTimestamp
- isValuePreservation, preservationType, estimatedPreservedValue
- currentUiBalance, currentUiBalanceString, balanceDecimals, balanceFetchedAt

#### PNL summary (PnlAnalysisService → SwapAnalysisSummary)
- totalVolume, totalFees, realizedPnl, unrealizedPnl, netPnl
- stablecoinNetFlow
- totalSignaturesProcessed
- profitableTokensCount, unprofitableTokensCount
- averageSwapSize
- totalExecutedSwapsCount
- averageRealizedPnlPerExecutedSwap
- realizedPnlToTotalVolumeRatio
- firstTransactionTimestamp, lastTransactionTimestamp
- overallFirstTimestamp, overallLastTimestamp
- currentSolBalance, balancesFetchedAt, tokenBalances

#### Advanced stats (AdvancedStatsAnalyzer → AdvancedTradeStats)
- medianPnlPerToken, trimmedMeanPnlPerToken
- tokenWinRatePercent
- standardDeviationPnl
- medianPnlToVolatilityRatio
- weightedEfficiencyScore
- averagePnlPerDayActiveApprox
- firstTransactionTimestamp (adv), lastTransactionTimestamp (adv)

#### PNL overview (PnlOverviewService → PnlOverviewResponseData)
- swapWinRate, avgPLTrade
- totalSolSpent, totalSolReceived

#### Behavior analysis (BehaviorAnalyzer → BehavioralMetrics)
- Flipper: buySellRatio, buySellSymmetry, averageFlipDurationHours, medianHoldTime, sequenceConsistency, flipperScore
- Activity: uniqueTokensTraded, tokensWithBothBuyAndSell, tokensWithOnlyBuys, tokensWithOnlySells, totalTradeCount, totalBuyCount, totalSellCount, completePairsCount, averageTradesPerToken
- Time distribution: tradingTimeDistribution, percentTradesUnder1Hour, percentTradesUnder4Hours
- Sessions: sessionCount, avgTradesPerSession, activeTradingPeriods, averageSessionStartHour, averageSessionDurationMinutes
- Preferences/Risk: tokenPreferences.mostTradedTokens, riskMetrics.averageTransactionValueSol, riskMetrics.largestTransactionValueSol
- Holding posture: averageCurrentHoldingDurationHours, medianCurrentHoldingDurationHours, weightedAverageHoldingDurationHours, percentOfValueInCurrentHoldings
- Classification: tradingStyle, confidenceScore
- Timestamps: firstTransactionTimestamp, lastTransactionTimestamp
- Reentry/Unpaired: reentryRate, percentageOfUnpairedTokens

---

### Derivations and where they’re calculated (brief “math”)

#### PNL per-token (SwapAnalyzer)
- netAmountChange = totalAmountIn − totalAmountOut
- netSolProfitLoss = totalSolReceived − totalSolSpent − totalFeesPaidInSol
- estimatedPreservedValue = current SOL value of net stablecoin holdings (stablecoins only)
- transferCountIn/Out: counts of buy/sell transfers per token
- first/lastTransferTimestamp: min/max over that token’s trades

#### PNL summary (PnlAnalysisService)
- totalVolume = Σ per-token (totalSolSpent + totalSolReceived)
- totalFees = Σ per-token totalFeesPaidInSol
- realizedPnl = Σ per-token netSolProfitLoss for non-stablecoins
- unrealizedPnl = Σ per-token estimatedPreservedValue for stablecoins
- netPnl = realizedPnl + unrealizedPnl
- stablecoinNetFlow: net SOL flow into/out of stablecoins
- totalSignaturesProcessed: distinct signatures considered in analysis
- profitableTokensCount = count(non-stablecoin tokens with netSolProfitLoss > 0)
- unprofitableTokensCount = count(non-stablecoin tokens with netSolProfitLoss < 0)
- averageSwapSize = totalVolume / (profitableTokensCount + unprofitableTokensCount)
- totalExecutedSwapsCount = Σ over non-stablecoins (transferCountIn + transferCountOut)
- averageRealizedPnlPerExecutedSwap = realizedPnl / totalExecutedSwapsCount (guard 0)
- realizedPnlToTotalVolumeRatio = realizedPnl / totalVolume (guard 0)
- firstTransactionTimestamp / lastTransactionTimestamp: summary-level min/max over inputs
- overallFirstTimestamp / overallLastTimestamp: min/max over all input swap records (explicitly broadest window)
- currentSolBalance, balancesFetchedAt, tokenBalances: from WalletBalanceService snapshot

#### Advanced stats (AdvancedStatsAnalyzer; typically non-stablecoins subset)
- medianPnlPerToken = median over token PNLs where PNL ≠ 0
- trimmedMeanPnlPerToken = mean after trimming extremes
- tokenWinRatePercent = 100 × (# tokens with PNL > WIN_THRESHOLD_SOL) / (# tokens with PNL ≠ 0)
- standardDeviationPnl = sample std dev over token PNLs
- medianPnlToVolatilityRatio = medianPnlPerToken / standardDeviationPnl (guard 0)
- weightedEfficiencyScore = custom function(avg PNL, win rate) with linear win rate impact
- averagePnlPerDayActiveApprox = PNL per token scaled by active span and averaged
- first/lastTransactionTimestamp (adv): min/max over analyzer input trades

#### PNL overview derivatives (PnlOverviewService)
- swapWinRate:
  - If individual-trade data present: (profitableTradeCount / totalIndividualTrades) × 100
  - Else: token-level proxy (profitableTokensCount / (profitable + unprofitable)) × 100
- avgPLTrade = realizedPnl / totalTrades (token-level fallback when needed)
- totalSolSpent = Σ per-token totalSolSpent
- totalSolReceived = Σ per-token totalSolReceived

#### Behavior analysis (BehaviorAnalyzer)
- Flipper metrics:
  - buySellRatio = totalBuyCount / totalSellCount (guard 0)
  - buySellSymmetry: average per-token symmetry for tokens with both sides
  - averageFlipDurationHours: mean buy→sell time across completed pairs
  - medianHoldTime: median of flip durations
  - sequenceConsistency: average (completed pairs / max possible pairs) per token
  - flipperScore: composite score (no overall ratio penalty)
- Activity:
  - uniqueTokensTraded: distinct mints
  - tokensWithBothBuyAndSell: tokens with ≥1 buy and ≥1 sell
  - tokensWithOnlyBuys, tokensWithOnlySells: counts by side-only
  - totalTradeCount = totalBuyCount + totalSellCount
  - averageTradesPerToken = totalTradeCount / uniqueTokensTraded (guard 0)
  - completePairsCount: total number of completed buy→sell pairs
- Time distribution:
  - tradingTimeDistribution: histogram of flip durations across buckets
  - percentTradesUnder1Hour/4Hours: share of flips in thresholds
- Sessions:
  - sessionCount: count of sequences where inter-trade gap ≤ threshold (e.g., 60m)
  - avgTradesPerSession = totalTradeCount / sessionCount (guard 0)
  - activeTradingPeriods:
    - hourlyTradeCounts: counts by UTC hour
    - identifiedWindows: adaptive thresholded consecutive hour windows
    - activityFocusScore: concentration measure (e.g., share in windows)
  - averageSessionStartHour: circular mean of session starts
  - averageSessionDurationMinutes: mean session length
- Preferences/Risk:
  - tokenPreferences.mostTradedTokens: top-N by (buy+sell) counts
  - riskMetrics.averageTransactionValueSol = Σ associatedSolValue / totalTradeCount (guard 0)
  - riskMetrics.largestTransactionValueSol = max associatedSolValue
- Holding posture:
  - average/median/weightedAverageCurrentHoldingDurationHours: stats over open positions; weighted by size for weighted average
  - percentOfValueInCurrentHoldings = 100 × (value of current holdings / total portfolio value) (guard 0)
- Classification:
  - tradingStyle, confidenceScore: derived from behavioral signals
- Timestamps:
  - first/lastTransactionTimestamp: min/max over input swaps
- Reentry/Unpaired:
  - reentryRate = tokensWithMultipleCycles / tokensWithBothBuyAndSell (guard 0)
  - percentageOfUnpairedTokens = 100 × ((uniqueTokensTraded − tokensWithBothBuyAndSell) / uniqueTokensTraded) (guard 0)