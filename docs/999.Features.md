# Future Feature Ideas

## Quick Summary of Features

*   **Dynamic Token Holder Tracking & Behavioral Clustering**
    *   **What it will do:** Dynamically track top SPL token holders, group them by initial transaction timeframes, and analyze clusters for coordinated behavior.
    *   **Benefit:** Identify potential market manipulations, coordinated pumps/dumps, or strategic entries/exits by influential wallet groups.
    *   **Status:** `Idea`
    *   **Priority:** `Medium`
    *   **Complexity:** `High`
    *   **Estimated Effort:** `L`

*   **Implement Skeleton Loaders for Dashboard UI** - COMPLETED
    *   **What it will do:** Replace or augment existing full-component loading states (like `EmptyState` with a spinner) with more granular skeleton placeholders that mimic the UI structure of components before data is loaded.
    *   **Benefit:** Improves perceived performance and user experience by providing immediate visual feedback on the shape and layout of content that is about to load, reducing abrupt layout shifts and making the application feel faster and smoother.
    *   **Status:** `Planned`
    *   **Priority:** `Medium`
    *   **Complexity:** `Medium`
    *   **Estimated Effort:** `S`

*   **Streaming Analysis Pipeline (Eliminate Sync Bottleneck)**
    *   **What it will do:** Replace sequential "sync-then-analyze" with streaming analysis that provides incremental results as transaction data is processed.
    *   **Benefit:** Eliminates the primary bottleneck where users wait for complete historical sync before seeing any results, especially for wallets with extensive transaction history.
    *   **Status:** `Idea`
    *   **Priority:** `Medium`
    *   **Complexity:** `Very High`
    *   **Estimated Effort:** `XL`

This document outlines potential new features and enhancements for the Solana On-Chain Swap & P/L Analyzer.

## Table of Contents

1. 
2.  [Feature Idea Template](#feature-idea-template)
3.  [Specific Feature Ideas](#specific-feature-ideas)
    *   [Dynamic Token Holder Tracking & Behavioral Clustering](#dynamic-token-holder-tracking--behavioral-clustering)
    *   [Implement Skeleton Loaders for Dashboard UI](#implement-skeleton-loaders-for-dashboard-ui) - **COMPLETED**
    *   [Live Token Valuation in Similarity Analysis](#live-token-valuation-in-similarity-analysis)
    *   [Streaming Analysis Pipeline (Eliminate Sync Bottleneck)](#streaming-analysis-pipeline-eliminate-sync-bottleneck)
    *   *(Add other feature ideas here)*

---

## Feature Idea Template

*(Use this template for new feature ideas)*

### 1. Feature Title: `[Concise Title]`

*   **Status:** `Idea | Planned | In Progress | Implemented | Deferred`
*   **Priority:** `Low | Medium | High | Critical`
*   **Complexity:** `Low | Medium | High | Very High`
*   **Estimated Effort:** `XS | S | M | L | XL` (e.g., XS < 1 day, S = 1-3 days, M = 3-7 days, L = 1-2 weeks, XL > 2 weeks)
*   **Related To (Services/Modules):** `e.g., helius-api-client, database-service, core/analysis/new-module`

### 2. Description

*(Briefly describe the feature and its goal. What problem does it solve or what value does it add?)*

### 3. Key Components & High-Level Plan

*(Break down the feature into major components or steps.)*

*   **Component/Step 1:**
    *   Details...
*   **Component/Step 2:**
    *   Details...

### 4. Detailed Implementation Considerations

*   **Data Fetching:**
    *   *(e.g., New Helius endpoints, modifications to `helius-api-client.ts`)*
*   **Database Schema Changes (`prisma/schema.prisma`):**
    *   *(e.g., New models, relations, fields)*
*   **Service Layer Changes (`src/core/services/`):**
    *   *(e.g., New methods in `database-service.ts`, new services)*
*   **Analytical Logic (`src/core/analysis/`):**
    *   *(e.g., New algorithms, metrics, calculations)*
*   **API Endpoints (if applicable):**
    *   *(e.g., New routes, DTOs)*
*   **UI Changes (if applicable):**
    *   *(e.g., New charts, tables, views)*

### 5. Potential Challenges & Open Questions

*(List any foreseeable challenges, risks, or questions that need to be addressed.)*

### 6. Acceptance Criteria

*(How do we know when this feature is done and working correctly?)*

*   AC1: ...
*   AC2: ...

---

## Specific Feature Ideas

### Dynamic Token Holder Tracking & Behavioral Clustering

*   **Status:** `Idea`
*   **Priority:** `Medium` (Potentially High, depending on strategic goals)
*   **Complexity:** `High`
*   **Estimated Effort:** `L` (1-2 weeks, initial core functionality)
*   **Related To (Services/Modules):** `helius-api-client.ts`, `database-service.ts`, `prisma/schema.prisma`, `src/core/analysis/temporal-clustering/` (new), `src/core/analysis/behavioral/` (potentially)

### 1. Description

This feature aims to dynamically track the top holders of specific SPL tokens, group them based on the proximity of their initial transaction timeframes, and analyze these clusters for coordinated behavior. The goal is to identify potential market manipulations, coordinated pumps/dumps, or strategic entries/exits by influential wallet groups, especially in the early stages of a token or within specific market cap ranges.

### 2. Key Components & High-Level Plan

1.  **Top Holder Identification:**
    *   Periodically fetch the top N (e.g., 20) token holders for a target SPL token using the Helius `getTokenLargestAccounts` RPC method.
2.  **Initial Transaction Time Analysis:**
    *   For each top holder, fetch their transaction history to identify their *initial* transaction(s) involving the target token.
    *   Define criteria for what constitutes an "initial relevant transaction."
3.  **Temporal Wallet Clustering:**
    *   Group wallets whose initial transactions occurred within a tight timeframe (e.g., 1-3 minutes of each other).
    *   Develop a "Temporal Clustering Index" or confidence score based on the tightness of these timeframes.
4.  **Cluster Supply Analysis:**
    *   Calculate the percentage of the token's total supply held by each identified cluster at the time of formation.
    *   Track how this supply share evolves over time (e.g., decreases from 10% to 7% after X minutes/hours).
5.  **Behavioral Inference & Persistence Tracking:**
    *   Infer potential coordination based on shared entry windows.
    *   Monitor if clusters persist across different tokens or time periods, even with evolving membership.
    *   Track the dissolution of clusters.
6.  **Contextualization & Orchestration:**
    *   Allow this analysis to be triggered for specific tokens or dynamically based on criteria like market cap ranges or recent high-volume activity.
    *   Store and present the findings.

### 3. Detailed Implementation Considerations

*   **Data Fetching (`helius-api-client.ts`):**
    *   **New Method:** Implement `getTokenLargestAccounts(mintAddress: string, commitment?: string): Promise<HeliusLargestTokenAccount[]>`
        *   Response structure based on Helius docs: `address`, `amount`, `decimals`, `uiAmount`, `uiAmountString`.
    *   **New Method:** Implement `getTokenSupply(mintAddress: string, commitment?: string): Promise<HeliusTokenSupplyInfo>`
    *   Leverage existing `getAllTransactionsForAddress` to get transaction history for identified top holders.
    *   Leverage existing `getTokenAccountsByOwner` (called with a specific `mintPubkey`) to get current balances of cluster members for a specific token.
    *   Consider rate limiting and batching strategies for all new and existing calls.

*   **Database Schema Changes (`prisma/schema.prisma`):**
    *   **(New Model) `TrackedToken`:**
        *   `id String @id @default(cuid())`
        *   `mintAddress String @unique`
        *   `symbol String?`
        *   `name String?`
        *   `lastAnalyzedTopHolders DateTime?`
        *   `marketCap Float?` // Potentially fetched and stored
        *   `// Other relevant token metadata`
    *   **(New Model) `TokenHolderSnapshot`:**
        *   `id String @id @default(cuid())`
        *   `trackedTokenMint String` // FK to TrackedToken.mintAddress
        *   `trackedToken TrackedToken @relation(fields: [trackedTokenMint], references: [mintAddress])`
        *   `snapshotTimestamp DateTime @default(now())`
        *   `holderAddress String`
        *   `tokenAccountAddress String`
        *   `rawAmount String`
        *   `uiAmountString String`
        *   `isTopHolder Boolean @default(true)` // To distinguish if this was part of a top N scan
    *   **(New Model) `WalletCluster`:**
        *   `id String @id @default(cuid())`
        *   `trackedTokenMint String` // FK to TrackedToken.mintAddress
        *   `trackedToken TrackedToken @relation(fields: [trackedTokenMint], references: [mintAddress])`
        *   `formationTimestamp DateTime @default(now())` // Approx. time cluster was identified
        *   `firstTransactionTime DateTime` // Earliest tx time in cluster
        *   `lastTransactionTime DateTime` // Latest tx time in cluster (for initial grouping)
        *   `timeframeInSeconds Int` // Duration of the entry window
        *   `initialSupplyPercentage Float?`
        *   `confidenceScore Float?` // Temporal Clustering Index
        *   `notes String?`
    *   **(New Model) `WalletClusterMember`:**
        *   `id String @id @default(cuid())`
        *   `clusterId String` // FK to WalletCluster.id
        *   `cluster WalletCluster @relation(fields: [clusterId], references: [id])`
        *   `walletAddress String`
        *   `initialTransactionSignature String?`
        *   `initialTransactionTimestamp DateTime?`
        *   `initialHoldingsUiAmountString String?`
        *   `@@unique([clusterId, walletAddress])`
    *   **(New Model) `ClusterSupplyEvolution`:**
        *   `id String @id @default(cuid())`
        *   `clusterId String` // FK to WalletCluster.id
        *   `cluster WalletCluster @relation(fields: [clusterId], references: [id])`
        *   `snapshotTimestamp DateTime @default(now())`
        *   `currentSupplyPercentage Float`
        *   `memberCount Int` // Active members at this snapshot

*   **Service Layer Changes (`src/core/services/`):**
    *   **(New Dedicated Service) `TokenAnalyticsPersistenceService.ts` (or `ClusterDataRepository.ts`):**
        *   Create this new service to handle all database interactions for this feature's specific models (`TrackedToken`, `TokenHolderSnapshot`, `WalletCluster`, `WalletClusterMember`, `ClusterSupplyEvolution`).
        *   This service will contain all necessary CRUD (Create, Read, Update, Delete) methods and specialized query methods for these new entities.
        *   **Rationale:** This approach is preferred to avoid further increasing the size of the existing `database-service.ts` and to promote better separation of concerns and maintainability, as discussed regarding large service files. This new service will be injected with the Prisma client instance.
    *   **(New Service) `TokenAnalyticsOrchestrationService` (or similar):**
        *   Manages which tokens to analyze.
        *   Coordinates calls to `helius-api-client.ts` for top holders, supply.
        *   Triggers the clustering analysis.
        *   Schedules periodic re-analysis.
    *   **`wallet-balance-service.ts`:**
        *   Its pattern of using `heliusClient.getTokenAccountsByOwner` for specific mints will be useful. No direct changes might be needed if `HeliusApiClient` is enhanced and used directly by the new analysis modules.

*   **Analytical Logic (`src/core/analysis/` - potentially new subdirectories like `temporal-clustering/`, `holder-tracking/`):**
    *   **Module 1: Initial Transaction Identification:**
        *   Input: Wallet address, token mint.
        *   Output: Timestamp of the first relevant transaction (e.g., first buy, first interaction).
        *   Logic: Fetch transactions, filter by token mint, identify first swap/transfer-in.
    *   **Module 2: Temporal Clustering Algorithm:**
        *   Input: List of (wallet address, initial transaction timestamp, initial holdings).
        *   Output: List of `WalletCluster` objects with their members.
        *   Logic: Sort wallets by transaction timestamp. Iterate and group wallets whose timestamps fall within `X` minutes of each other. Calculate timeframe duration and confidence score.
    *   **Module 3: Cluster Supply Calculation:**
        *   Input: `WalletCluster` object, list of member current balances for the token, total token supply.
        *   Output: Supply percentage held by the cluster.
    *   **Module 4: Cluster Evolution Tracking:**
        *   Input: `WalletCluster` ID, current balances of original members.
        *   Output: Updated supply percentage, active member count.
        *   Logic: Periodically re-fetch balances for cluster members, compare to total supply.
    *   **Module 5: Persistence & Dissolution Analysis:**
        *   Logic to compare new clusters against historical ones to identify recurring patterns or persistent entities.
        *   Define criteria for when a cluster is considered "dissolved" or significantly changed.

*   **API Endpoints (if applicable, for dashboard/reporting):**
    *   `/api/v1/tokens/{mintAddress}/top-holder-clusters`
    *   `/api/v1/clusters/{clusterId}/evolution`

### 4. Potential Challenges & Open Questions

*   **Defining "Initial Relevant Transaction":** Is it the very first buy, first interaction, or first significant buy? Needs clear definition.
*   **Timeframe Thresholds:** What is a "tight timeframe" (1 min, 3 min, 5 min)? This might need to be configurable or adaptive based on token volatility/age.
*   **API Rate Limits:** Continuous polling for many tokens and their holders can be intensive. Smart scheduling, caching, and respecting Helius rate limits are critical. Consider WebSocket subscriptions if Helius supports them for relevant events.
*   **Data Volume & Performance:** Storing snapshots and evolution data can lead to large tables. Efficient querying and potential data archiving strategies might be needed.
*   **Scalability of Analysis:** Processing many tokens and their transaction histories needs to be performant.
*   **Market Cap Data Source:** If contextualizing by market cap, a reliable source for this data is needed (Helius or third-party like CoinGecko, Birdeye).
*   **False Positives/Negatives:** Coincidental timing vs. actual coordination. The confidence score and further behavioral analysis will be important.
*   **Defining Cluster Persistence:** How many overlapping members are needed to consider a group "persistent"?

### 5. Acceptance Criteria

*   AC1: System can fetch and store the top N holders for a given SPL token.
*   AC2: System can identify the initial transaction timestamp for a given wallet and token.
*   AC3: Wallets can be clustered based on configurable initial transaction time proximity.
*   AC4: The system calculates and stores the initial supply percentage held by an identified cluster.
*   AC5: The system can periodically track and store the evolution of a cluster's supply percentage and membership.
*   AC6: (Stretch) Clusters can be flagged if they reappear across different tokens or significant time gaps with substantial member overlap.
*   AC7: (Stretch) Analysis can be filtered or prioritized for tokens within specific market cap ranges.

---

### Implement Skeleton Loaders for Dashboard UI

*   **Status:** `COMPLETED`
*   **Priority:** `Medium`
*   **Complexity:** `Medium`
*   **Estimated Effort:** `S` (1-3 days for a comprehensive pass)
*   **Related To (Services/Modules):** `dashboard/src/components/shared/Skeleton.tsx` (if a custom wrapper is made), various dashboard components (e.g., `AccountSummaryCard.tsx`, `TokenPerformanceTab.tsx`, `AccountStatsPnlTab.tsx`, `BehavioralPatternsTab.tsx`).

### 1. Description

This feature involves implementing skeleton loader patterns across the dashboard UI. Instead of or in addition to showing a general loading spinner for an entire component or tab (e.g., using `EmptyState.tsx` with `Loader2`), skeleton loaders provide a more refined user experience by rendering placeholder shapes that mimic the structure of the content that is about to load. This makes the application feel faster and reduces layout shifts.

### 2. Key Components & High-Level Plan

1.  **Identify Key Components for Skeleton Loaders:**
    *   Review major dashboard components and identify areas where data loading causes noticeable delays or where a skeleton UI would significantly improve perceived performance (e.g., `AccountSummaryCard`, individual cards within tabs like `AccountStatsPnlTab`, rows in `TokenPerformanceTab` before data populates).- PAY ATTENTION: potentially these are the best candidates: Summary card headers, PNL table rows (blurred bars), Behavioral stat grids


2.  **Design Skeleton Structures:**
    *   For each identified component/area, design a corresponding skeleton structure using `shadcn/ui`'s `<Skeleton />` component. This involves arranging multiple `<Skeleton />` elements to represent text lines, blocks, chart areas, etc.
3.  **Integrate into Loading States:**
    *   Modify the relevant components to display their designed skeleton UI during their respective loading states. This might involve:
        *   Showing skeletons while SWR is in its `isLoading` state.
        *   Potentially combining with `EmptyState` (e.g., `EmptyState` for initial global load, then skeletons for content within).
4.  **Ensure Consistency:**
    *   Maintain a consistent style and animation for skeleton loaders across the dashboard.

### 3. Detailed Implementation Considerations

*   **UI Changes (Dashboard Components):**
    *   **`AccountSummaryCard.tsx`**: Design skeleton for the metrics displayed.
    *   **`TokenPerformanceTab.tsx`**: Design skeleton for table rows (e.g., a few rows of skeletons) and potentially for filter/summary areas if they load separately.
    *   **`AccountStatsPnlTab.tsx`**: Design skeletons for the "Period Specific" and "All-Time" data cards.
    *   **`BehavioralPatternsTab.tsx`**: Design skeletons for the metric cards and chart placeholders.
    *   **`FavoriteWalletsList.tsx` / `WalletSearch.tsx` (Popover Content):** Consider if skeletons are beneficial here for list items.
    *   **Reusable Skeleton Patterns:** If common layout patterns emerge (e.g., a card with a title and a few lines of text), consider creating small, reusable skeleton sub-components.

*   **Component Logic:**
    *   Update `isLoading` conditions in components to render the skeleton UI instead of, or before, rendering the `EmptyState` or `null`.

### 4. Potential Challenges & Open Questions

*   **Complexity vs. Benefit:** For very simple components, a full skeleton might be overkill if a simple spinner is sufficient. Need to balance implementation effort with UX gain.
*   **Maintaining Skeletons:** As UI components evolve, their corresponding skeletons will also need to be updated.
*   **Overuse:** Avoid making the UI too "busy" with excessive skeleton animations.

### 5. Acceptance Criteria

*   AC1: Key data-driven components in the dashboard display a skeleton placeholder UI that mimics their structure during their loading phase.
*   AC2: Skeleton loaders are visually consistent with the application's theme.
*   AC3: The introduction of skeleton loaders measurably improves the perceived loading experience (e.g., makes the UI feel more responsive).
*   AC4: Existing loading states (e.g., `EmptyState` for global analysis or critical errors) still function correctly and are used appropriately in conjunction with skeletons.

---

### Live Token Valuation in Similarity Analysis

*   **Status:** `Idea`
*   **Priority:** `Medium`
*   **Complexity:** `High`
*   **Estimated Effort:** `M`
*   **Related To (Services/Modules):** `SimilarityApiService`, `DexscreenerService`, `dashboard/ContextualHoldingsCard.tsx`, `Job Queue (future)`, `Token Price Registry (future)`

### 1. Description

Enhance the Similarity Analysis Lab by integrating real-time USD valuation for wallet holdings. This will allow for more insightful analysis based on capital allocation and provide immediate context on the significance of each token holding directly in the UI. This feature depends on the future implementation of a robust background job queue (e.g., BullMQ) and a dedicated Token Price Registry service to handle price fetching efficiently without blocking primary analysis tasks.

### 2. Key Components & High-Level Plan

1.  **Token Price Registry Service:** A new service responsible for fetching and caching token prices from sources like Dexscreener or Birdeye. It would be updated periodically by a background worker.
2.  **Background Job Queue:** Implement BullMQ or a similar system to manage background tasks like price fetching.
3.  **Service Integration:** `SimilarityApiService` will interact with the Token Price Registry to get prices for tokens held by wallets.
4.  **UI Enhancement:** `ContextualHoldingsCard` will be updated to display the USD value of each holding and sort tokens by value, providing a clearer view of capital concentration.

### 3. Detailed Implementation Considerations

*   **`Token Price Registry`:**
    *   New DB model `TokenPrice` (`mint`, `priceUsd`, `updatedAt`).
    *   New service with methods like `getPrices(mints): Map<string, number>` and a background `updatePrices(mints)`.
*   **`Job Queue`:**
    *   Setup BullMQ producer/consumer.
    *   A recurring job to update prices for popular/tracked tokens.
*   **`SimilarityApiService`:**
    *   In an `enrich` step (called by a separate endpoint), fetch prices from the registry and add `valueUsd` to the token balance objects.
*   **`ContextualHoldingsCard.tsx`:**
    *   Re-introduce `formatUsdValue` helper.
    *   Display the USD value.
    *   Sort holdings by `valueUsd` descending.

### 4. Potential Challenges & Open Questions

*   **Price data accuracy and latency.**
*   **Rate limits** of price data sources.
*   **Infrastructure setup** for the job queue.

### 5. Acceptance Criteria

*   AC1: Token prices are fetched and stored in the database by a background worker.
*   AC2: The Similarity Lab UI has a mechanism (e.g., a refresh button) to enrich the holdings data with the latest cached prices.
*   AC3: The `ContextualHoldingsCard` displays the USD value for each token holding.
*   AC4: Holdings in the card are sorted from highest to lowest USD value.

### Sidebar Favorites: Live Trades Monitor

*   **Status:** `Planned`
*   **Priority:** `High`
*   **Complexity:** `Medium`
*   **Estimated Effort:** `M`
*   **Related To (Services/Modules):** `dashboard/src/components/sidebar/FavoriteWalletsList.tsx`, `dashboard/src/hooks/useFavorites.ts`, `dashboard/src/components/sidebar/WalletSearch.tsx`, `src/api/controllers/user-favorites.controller.ts`, `src/api/services/user-favorites.service.ts`, `src/api/shared/job-progress.gateway.ts`, `docs/1. scaling_plan.md`

### 1. Description

Introduce a live monitor for each favorite wallet directly in the sidebar. Each favorite shows an activity indicator for recent movements; a new monitor icon opens a compact live-trades popover listing recent swaps/buys/sells (token, amount, time). Optionally replace the current "wallets performance" display or offer both via a toggle. This leverages the webhook-favorites integration so events arrive in near real time; fall back to a lightweight REST fetch on reconnect.

### 2. Key Components & High-Level Plan

1.  **Sidebar UI Enhancements:**
    *   Add activity badge and a monitor icon next to each favorite; tooltip shows last event time and count in last N minutes.
    *   Popover view renders the latest 5–10 trades with side, token, amount, and timestamp, plus a link to a fuller monitor page.
    *   Setting to replace or augment the existing performance list.
2.  **Event Ingestion:**
    *   On favorite add/remove, (un)register the wallet in the Helius Enhanced Webhook as outlined in `docs/1. scaling_plan.md`.
    *   Webhook controller verifies, dedupes by signature, debounces per wallet, and publishes minimal activity payloads.
3.  **Realtime Delivery (WebSocket):**
    *   Extend the existing gateway (or add `WalletActivityGateway`) to broadcast `wallet-activity` events to channels like `wallet:<address>`.
    *   Client subscribes while sidebar is mounted; batch updates for smooth UX.
4.  **Persistence (optional, short retention):**
    *   Store last N events per wallet (24–48h) for reload resilience; expose REST `GET /favorites/activity` for bootstrap.
5.  **User Controls:**
    *   Noise filters (min amount, exclude transfers), retention window, auto-open monitor on activity.

### 3. Detailed Implementation Considerations

*   **Data Fetching / Webhooks:** Prefer Enhanced webhook for `SWAP`/`BUY`/`SELL`; fall back to raw decoding when needed. Debounce 2–5s per wallet, dedupe by signature.
*   **Database Schema Changes (`prisma/schema.prisma`) (optional):**
    *   `WalletActivityEvent` with fields: `id`, `walletAddress`, `signature` (unique), `type`, `tokenMint?`, `amount?`, `priceUsd?`, `side?`, `timestamp`; indexes on `walletAddress`, `timestamp` and TTL/archival policy.
*   **Service Layer Changes (`src/api/services/`):**
    *   `HeliusWebhookService` (new/enhanced) for verification, parsing, publishing.
    *   `WalletActivityService` (new) to persist/query recent events and broadcast.
    *   Update `UserFavoritesService` to manage webhook registrations on add/remove.
*   **API & Sockets:**
    *   `POST /integrations/helius/webhook` receiver; `GET /favorites/activity` bootstrap; WebSocket `wallet-activity` topic.
*   **UI Changes (Dashboard):**
    *   Update `FavoriteWalletsList.tsx` to render badges and a monitor icon; subscribe to `wallet-activity`; add a `LiveTradesPopover` component.

### 4. Potential Challenges & Open Questions

*   Noise from highly active wallets; provide demotion/backoff similar to scaling plan.
*   Accurate BUY/SELL labeling under different program decoders.
*   Socket lifecycle and memory: ensure unsubscribe on unmount and on favorites change.
*   Batching/limits for high-frequency bursts to avoid UI jank.

### 5. Acceptance Criteria

*   AC1: Activity indicator updates within 3 seconds of a relevant transaction on a tracked favorite wallet.
*   AC2: Popover shows at least the last 5–10 recent activities with side, token, amount, and timestamp, updating live.
*   AC3: Integration is driven by the favorites–webhook flow; when sockets reconnect, recent activity appears via REST bootstrap.
*   AC4: Users can choose to replace or augment the current performance list; the choice persists.
*   AC5: Debounce/dedupe prevents duplicates; indicators clear after a configurable quiet period.

### Streaming Analysis Pipeline (Eliminate Sync Bottleneck)

*   **Status:** `Idea`
*   **Priority:** `Medium`
*   **Complexity:** `Very High`
*   **Estimated Effort:** `XL` (3+ weeks, major architectural change)
*   **Related To (Services/Modules):** `HeliusSyncService`, `analysis-operations.processor.ts`, `PnlAnalysisService`, `BehaviorService`, WebSocket streaming architecture

### 1. Description

Replace the current "sync-then-analyze" sequential pattern with a streaming analysis pipeline that can perform incremental analysis as new transaction data arrives. This would eliminate the primary bottleneck where users wait for complete historical sync before seeing any results, especially for wallets with extensive transaction history.

### 2. Key Components & High-Level Plan

1.  **Incremental Sync with Analysis Callbacks:**
    *   Modify `HeliusSyncService` to trigger analysis callbacks as batches of transactions are processed
    *   Implement progressive analysis that updates results incrementally
2.  **Streaming WebSocket Updates:**
    *   Send partial analysis results to frontend as they become available
    *   Update progress with meaningful metrics (e.g., "Analyzed 500/2000 transactions")
3.  **Smart Prioritization:**
    *   Analyze recent transactions first for quick initial insights
    *   Fill in historical data progressively in background
4.  **Checkpoint System:**
    *   Save analysis state at intervals to allow resuming interrupted processes
    *   Enable "good enough" results for user interaction while background processing continues

### 3. Detailed Implementation Considerations

*   **Sync Service Changes:**
    *   Add callback system to `syncWalletData()` that fires after each batch of transactions
    *   Implement "recent-first" sync ordering option
*   **Analysis Service Refactoring:**
    *   Make PnL and behavior analysis services support incremental updates
    *   Design mergeable result structures that can be combined as more data arrives
*   **Database Strategy:**
    *   Implement analysis checkpointing to persist intermediate results
    *   Design schema for progressive result updates
*   **Frontend Changes:**
    *   Update UI to handle and display incremental results
    *   Show progressive loading with meaningful progress indicators

### 4. Potential Challenges & Open Questions

*   **Complexity**: This is a fundamental architectural change affecting multiple core systems
*   **Result Consistency**: Ensuring incremental results converge to the same final state as batch processing
*   **Memory Management**: Handling large transaction datasets without memory leaks
*   **Error Recovery**: Graceful handling of interrupted streaming processes
*   **User Experience**: Designing UI that effectively communicates progressive loading state

### 5. Acceptance Criteria

*   AC1: Users see initial analysis results within 30 seconds for any wallet, regardless of transaction volume
*   AC2: Analysis continues to improve progressively as more historical data is processed
*   AC3: System maintains accuracy equivalent to current batch processing approach
*   AC4: Interrupted analysis can resume from checkpoints rather than restarting
*   AC5: UI provides clear indication of analysis completion percentage and data freshness

---
*(Add other feature ideas below following the template)*
