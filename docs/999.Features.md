# Future Feature Ideas

This document outlines potential new features and enhancements for the Solana On-Chain Swap & P/L Analyzer.

## Table of Contents

1.  [Feature Idea Template](#feature-idea-template)
2.  [Specific Feature Ideas](#specific-feature-ideas)
    *   [Dynamic Token Holder Tracking & Behavioral Clustering](#dynamic-token-holder-tracking--behavioral-clustering)
    *   *(Add other feature ideas here)*

---

## Feature Idea Template

*(Use this template for new feature ideas)*

### 1. Feature Title: `[Concise Title]`

*   **Status:** `Idea | Planned | In Progress | Implemented | Deferred`
*   **Priority:** `Low | Medium | High | Critical`
*   **Complexity:** `Low | Medium | High | Very High`
*   **Estimated Effort:** `XS | S | M | L | XL` (e.g., XS < 1 day, S = 1-3 days, M = 3-7 days, L = 1-2 weeks, XL > 2 weeks)
*   **Related To (Services/Modules):** `e.g., helius-api-client, database-service, core/analysis/new-module`

### 2. Description

*(Briefly describe the feature and its goal. What problem does it solve or what value does it add?)*

### 3. Key Components & High-Level Plan

*(Break down the feature into major components or steps.)*

*   **Component/Step 1:**
    *   Details...
*   **Component/Step 2:**
    *   Details...

### 4. Detailed Implementation Considerations

*   **Data Fetching:**
    *   *(e.g., New Helius endpoints, modifications to `helius-api-client.ts`)*
*   **Database Schema Changes (`prisma/schema.prisma`):**
    *   *(e.g., New models, relations, fields)*
*   **Service Layer Changes (`src/core/services/`):**
    *   *(e.g., New methods in `database-service.ts`, new services)*
*   **Analytical Logic (`src/core/analysis/`):**
    *   *(e.g., New algorithms, metrics, calculations)*
*   **API Endpoints (if applicable):**
    *   *(e.g., New routes, DTOs)*
*   **UI Changes (if applicable):**
    *   *(e.g., New charts, tables, views)*

### 5. Potential Challenges & Open Questions

*(List any foreseeable challenges, risks, or questions that need to be addressed.)*

### 6. Acceptance Criteria

*(How do we know when this feature is done and working correctly?)*

*   AC1: ...
*   AC2: ...

---

## Specific Feature Ideas

### Dynamic Token Holder Tracking & Behavioral Clustering

*   **Status:** `Idea`
*   **Priority:** `Medium` (Potentially High, depending on strategic goals)
*   **Complexity:** `High`
*   **Estimated Effort:** `L` (1-2 weeks, initial core functionality)
*   **Related To (Services/Modules):** `helius-api-client.ts`, `database-service.ts`, `prisma/schema.prisma`, `src/core/analysis/temporal-clustering/` (new), `src/core/analysis/behavioral/` (potentially)

### 1. Description

This feature aims to dynamically track the top holders of specific SPL tokens, group them based on the proximity of their initial transaction timeframes, and analyze these clusters for coordinated behavior. The goal is to identify potential market manipulations, coordinated pumps/dumps, or strategic entries/exits by influential wallet groups, especially in the early stages of a token or within specific market cap ranges.

### 2. Key Components & High-Level Plan

1.  **Top Holder Identification:**
    *   Periodically fetch the top N (e.g., 20) token holders for a target SPL token using the Helius `getTokenLargestAccounts` RPC method.
2.  **Initial Transaction Time Analysis:**
    *   For each top holder, fetch their transaction history to identify their *initial* transaction(s) involving the target token.
    *   Define criteria for what constitutes an "initial relevant transaction."
3.  **Temporal Wallet Clustering:**
    *   Group wallets whose initial transactions occurred within a tight timeframe (e.g., 1-3 minutes of each other).
    *   Develop a "Temporal Clustering Index" or confidence score based on the tightness of these timeframes.
4.  **Cluster Supply Analysis:**
    *   Calculate the percentage of the token's total supply held by each identified cluster at the time of formation.
    *   Track how this supply share evolves over time (e.g., decreases from 10% to 7% after X minutes/hours).
5.  **Behavioral Inference & Persistence Tracking:**
    *   Infer potential coordination based on shared entry windows.
    *   Monitor if clusters persist across different tokens or time periods, even with evolving membership.
    *   Track the dissolution of clusters.
6.  **Contextualization & Orchestration:**
    *   Allow this analysis to be triggered for specific tokens or dynamically based on criteria like market cap ranges or recent high-volume activity.
    *   Store and present the findings.

### 3. Detailed Implementation Considerations

*   **Data Fetching (`helius-api-client.ts`):**
    *   **New Method:** Implement `getTokenLargestAccounts(mintAddress: string, commitment?: string): Promise<HeliusLargestTokenAccount[]>`
        *   Response structure based on Helius docs: `address`, `amount`, `decimals`, `uiAmount`, `uiAmountString`.
    *   **New Method:** Implement `getTokenSupply(mintAddress: string, commitment?: string): Promise<HeliusTokenSupplyInfo>`
    *   Leverage existing `getAllTransactionsForAddress` to get transaction history for identified top holders.
    *   Leverage existing `getTokenAccountsByOwner` (called with a specific `mintPubkey`) to get current balances of cluster members for a specific token.
    *   Consider rate limiting and batching strategies for all new and existing calls.

*   **Database Schema Changes (`prisma/schema.prisma`):**
    *   **(New Model) `TrackedToken`:**
        *   `id String @id @default(cuid())`
        *   `mintAddress String @unique`
        *   `symbol String?`
        *   `name String?`
        *   `lastAnalyzedTopHolders DateTime?`
        *   `marketCap Float?` // Potentially fetched and stored
        *   `// Other relevant token metadata`
    *   **(New Model) `TokenHolderSnapshot`:**
        *   `id String @id @default(cuid())`
        *   `trackedTokenMint String` // FK to TrackedToken.mintAddress
        *   `trackedToken TrackedToken @relation(fields: [trackedTokenMint], references: [mintAddress])`
        *   `snapshotTimestamp DateTime @default(now())`
        *   `holderAddress String`
        *   `tokenAccountAddress String`
        *   `rawAmount String`
        *   `uiAmountString String`
        *   `isTopHolder Boolean @default(true)` // To distinguish if this was part of a top N scan
    *   **(New Model) `WalletCluster`:**
        *   `id String @id @default(cuid())`
        *   `trackedTokenMint String` // FK to TrackedToken.mintAddress
        *   `trackedToken TrackedToken @relation(fields: [trackedTokenMint], references: [mintAddress])`
        *   `formationTimestamp DateTime @default(now())` // Approx. time cluster was identified
        *   `firstTransactionTime DateTime` // Earliest tx time in cluster
        *   `lastTransactionTime DateTime` // Latest tx time in cluster (for initial grouping)
        *   `timeframeInSeconds Int` // Duration of the entry window
        *   `initialSupplyPercentage Float?`
        *   `confidenceScore Float?` // Temporal Clustering Index
        *   `notes String?`
    *   **(New Model) `WalletClusterMember`:**
        *   `id String @id @default(cuid())`
        *   `clusterId String` // FK to WalletCluster.id
        *   `cluster WalletCluster @relation(fields: [clusterId], references: [id])`
        *   `walletAddress String`
        *   `initialTransactionSignature String?`
        *   `initialTransactionTimestamp DateTime?`
        *   `initialHoldingsUiAmountString String?`
        *   `@@unique([clusterId, walletAddress])`
    *   **(New Model) `ClusterSupplyEvolution`:**
        *   `id String @id @default(cuid())`
        *   `clusterId String` // FK to WalletCluster.id
        *   `cluster WalletCluster @relation(fields: [clusterId], references: [id])`
        *   `snapshotTimestamp DateTime @default(now())`
        *   `currentSupplyPercentage Float`
        *   `memberCount Int` // Active members at this snapshot

*   **Service Layer Changes (`src/core/services/`):**
    *   **(New Dedicated Service) `TokenAnalyticsPersistenceService.ts` (or `ClusterDataRepository.ts`):**
        *   Create this new service to handle all database interactions for this feature's specific models (`TrackedToken`, `TokenHolderSnapshot`, `WalletCluster`, `WalletClusterMember`, `ClusterSupplyEvolution`).
        *   This service will contain all necessary CRUD (Create, Read, Update, Delete) methods and specialized query methods for these new entities.
        *   **Rationale:** This approach is preferred to avoid further increasing the size of the existing `database-service.ts` and to promote better separation of concerns and maintainability, as discussed regarding large service files. This new service will be injected with the Prisma client instance.
    *   **(New Service) `TokenAnalyticsOrchestrationService` (or similar):**
        *   Manages which tokens to analyze.
        *   Coordinates calls to `helius-api-client.ts` for top holders, supply.
        *   Triggers the clustering analysis.
        *   Schedules periodic re-analysis.
    *   **`wallet-balance-service.ts`:**
        *   Its pattern of using `heliusClient.getTokenAccountsByOwner` for specific mints will be useful. No direct changes might be needed if `HeliusApiClient` is enhanced and used directly by the new analysis modules.

*   **Analytical Logic (`src/core/analysis/` - potentially new subdirectories like `temporal-clustering/`, `holder-tracking/`):**
    *   **Module 1: Initial Transaction Identification:**
        *   Input: Wallet address, token mint.
        *   Output: Timestamp of the first relevant transaction (e.g., first buy, first interaction).
        *   Logic: Fetch transactions, filter by token mint, identify first swap/transfer-in.
    *   **Module 2: Temporal Clustering Algorithm:**
        *   Input: List of (wallet address, initial transaction timestamp, initial holdings).
        *   Output: List of `WalletCluster` objects with their members.
        *   Logic: Sort wallets by transaction timestamp. Iterate and group wallets whose timestamps fall within `X` minutes of each other. Calculate timeframe duration and confidence score.
    *   **Module 3: Cluster Supply Calculation:**
        *   Input: `WalletCluster` object, list of member current balances for the token, total token supply.
        *   Output: Supply percentage held by the cluster.
    *   **Module 4: Cluster Evolution Tracking:**
        *   Input: `WalletCluster` ID, current balances of original members.
        *   Output: Updated supply percentage, active member count.
        *   Logic: Periodically re-fetch balances for cluster members, compare to total supply.
    *   **Module 5: Persistence & Dissolution Analysis:**
        *   Logic to compare new clusters against historical ones to identify recurring patterns or persistent entities.
        *   Define criteria for when a cluster is considered "dissolved" or significantly changed.

*   **API Endpoints (if applicable, for dashboard/reporting):**
    *   `/api/v1/tokens/{mintAddress}/top-holder-clusters`
    *   `/api/v1/clusters/{clusterId}/evolution`

### 4. Potential Challenges & Open Questions

*   **Defining "Initial Relevant Transaction":** Is it the very first buy, first interaction, or first significant buy? Needs clear definition.
*   **Timeframe Thresholds:** What is a "tight timeframe" (1 min, 3 min, 5 min)? This might need to be configurable or adaptive based on token volatility/age.
*   **API Rate Limits:** Continuous polling for many tokens and their holders can be intensive. Smart scheduling, caching, and respecting Helius rate limits are critical. Consider WebSocket subscriptions if Helius supports them for relevant events.
*   **Data Volume & Performance:** Storing snapshots and evolution data can lead to large tables. Efficient querying and potential data archiving strategies might be needed.
*   **Scalability of Analysis:** Processing many tokens and their transaction histories needs to be performant.
*   **Market Cap Data Source:** If contextualizing by market cap, a reliable source for this data is needed (Helius or third-party like CoinGecko, Birdeye).
*   **False Positives/Negatives:** Coincidental timing vs. actual coordination. The confidence score and further behavioral analysis will be important.
*   **Defining Cluster Persistence:** How many overlapping members are needed to consider a group "persistent"?

### 5. Acceptance Criteria

*   AC1: System can fetch and store the top N holders for a given SPL token.
*   AC2: System can identify the initial transaction timestamp for a given wallet and token.
*   AC3: Wallets can be clustered based on configurable initial transaction time proximity.
*   AC4: The system calculates and stores the initial supply percentage held by an identified cluster.
*   AC5: The system can periodically track and store the evolution of a cluster's supply percentage and membership.
*   AC6: (Stretch) Clusters can be flagged if they reappear across different tokens or significant time gaps with substantial member overlap.
*   AC7: (Stretch) Analysis can be filtered or prioritized for tokens within specific market cap ranges.

---
*(Add other feature ideas below following the template)*
