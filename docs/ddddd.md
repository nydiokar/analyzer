We didn't see this "CPU-blocking" fallacy before because the code was complicated with data-fetching redundancies. Our recent cleanup, while correct, made the real bottleneck visible for the first time.
Yes, you should absolutely commit the changes we just made. They are valuable and correct. That refactoring simplified the data flow and was a necessary step to even be able to see this deeper issue clearly.
Let's outline the final, definitive plan to fix this architectural flaw.
Pathway to the Definitive Fix
Here is the table comparing the current, flawed state with the target state that will provide true parallelism.
Component	Current State (The Problem)	Target State (The Solution)
Execution Model	All jobs (similarity, enrichment, etc.) run in the same single Node.js process. A heavy, CPU-bound job like the similarity analysis blocks the entire process, starving other jobs.	The heavy Similarity job will run in a separate, sandboxed child process. This isolates its CPU usage, freeing the main process to run the lightweight Enrichment job in true parallel.
SimilarityOperationsProcessor.ts	The processor is an @Injectable NestJS class. The processing logic (processSimilarityFlow) lives inside it. The BullMQ Worker is created in the constructor to run this internal logic.	The processor class will remain, but its Worker will be configured to run a standalone file (e.g., similarity.worker.ts). The core logic from processSimilarityFlow will be moved into this new file.
EnrichmentOperationsProcessor.ts	Runs in the main process and gets starved for CPU time.	No changes needed. It will remain in the main process and will now have the free CPU resources to run immediately, in parallel with the sandboxed similarity job.
Frontend State (page.tsx)	The currentJobId is not cleared after the main analysis job finishes, causing the UI to ignore the subsequent (and legitimate) enrichment job completion event.	Add setCurrentJobId(null) inside the onJobCompleted callback after the main job's results are successfully handled. This ensures the component is ready to process the enrichment job's completion.
This plan addresses the root cause of the performance issue and the remaining UI bug. By moving the heavy lifting to a sandboxed process, we guarantee that the main application remains responsive and can execute lightweight tasks like the enrichment job concurrently.