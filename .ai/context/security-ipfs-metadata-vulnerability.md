# Security: IPFS Metadata Fetching Vulnerability

**Date Identified**: 2025-01-28
**Date Implemented**: 2025-11-06
**Severity**: HIGH
**Status**: ✅ FULLY IMPLEMENTED AND TESTED
**Affected Component**: `src/core/services/onchain-metadata.service.ts`

---

## Current Situation (Before Patch)

The system was fetching token metadata from IPFS/Arweave URIs without security protections:

1. **No validation**: System accepted any URI format, including:
   - Direct IP addresses (potential SSRF risk)
   - HTTP (non-encrypted) endpoints
   - Private network addresses
   - Suspicious hostnames

3. **No size limits**: Response data is accumulated without size checks, allowing:
   - Memory exhaustion attacks (DoS)
   - Large file downloads consuming server resources

4. **No sanitization**: Parsed JSON is used directly without:
   - Prototype pollution protection
   - Depth limits (stack overflow risk)
   - Type validation
   - Content-Type verification

---

## Identified Vulnerabilities

### 1. Memory Exhaustion (DoS)
**Risk**: HIGH  
**Attack Vector**: Attacker uploads large JSON file (1GB+) to IPFS and points token metadata URI to it.

**Current Code**:
```typescript
let data = '';
res.on('data', (chunk) => {
  data += chunk;  // No size limit check
});
```

**Impact**: 
- Server memory exhaustion
- Potential crashes
- Service unavailability

### 2. Prototype Pollution
**Risk**: MEDIUM  
**Attack Vector**: Malicious JSON with `__proto__`, `constructor`, or `prototype` keys.

**Example Attack Payload**:
```json
{
  "__proto__": {"isAdmin": true},
  "twitter": "https://evil.com"
}
```

**Impact**: 
- Object prototype contamination
- Potential security bypass if data is merged unsafely
- Unpredictable behavior

### 3. SSRF (Server-Side Request Forgery)
**Risk**: HIGH  
**Attack Vector**: IP address URIs or private network endpoints.

**Observed Examples**:
- `http://95.179.167.134:3000/metadata/YWKUMA`
- Potential access to internal services if not properly isolated

**Impact**:
- Internal network reconnaissance
- Access to internal-only services
- Data exfiltration

### 4. Stack Overflow / Deep Nesting
**Risk**: MEDIUM  
**Attack Vector**: Extremely nested JSON structures.

**Example**:
```json
{"a": {"a": {"a": ... // 10,000 levels deep
```

**Impact**:
- Stack overflow crashes
- High CPU usage during parsing
- Service degradation

### 5. No Content-Type Validation
**Risk**: LOW  
**Attack Vector**: Non-JSON responses served as JSON.

**Impact**:
- Parsing errors (handled, but inefficient)
- Potential confusion if HTML/JS is returned

---

## Mitigation Strategy

### Phase 1: Critical Protections (IMMEDIATE)

1. **Size Limits**
   - Maximum response size: 5MB
   - Check during streaming (destroy connection if exceeded)
   - Reject immediately, no retries

2. **URI Validation**
   - Reject IP addresses (require hostnames)
   - Reject private network addresses (192.168.x.x, 10.x.x.x, etc.)
   - Reject localhost variants
   - Prefer HTTPS over HTTP (warning for HTTP)
   - Whitelist common gateways (ipfs.io, arweave.net, etc.) or reject suspicious hosts

3. **Prototype Pollution Protection**
   - Strip `__proto__`, `constructor`, `prototype` keys during parsing
   - Use safe object creation (`Object.create(null)`)
   - Sanitize all parsed data before use

### Phase 2: Enhanced Security (SHORT TERM)

4. **JSON Depth Limits**
   - Maximum nesting depth: 20 levels
   - Reject deeper structures
   - Prevent stack overflow

5. **Array/Value Limits**
   - Maximum array size: 1,000 elements
   - Maximum string length: 10,000 characters
   - Truncate or reject larger values

6. **Content-Type Verification**
   - Verify `Content-Type: application/json` header
   - Log warnings for unexpected types
   - Consider rejecting non-JSON types

7. **Safe Logging**
   - Sanitize URIs in logs (remove query params, credentials)
   - Truncate long URIs
   - Don't log sensitive data

### Implementation Details

**File**: `src/core/services/onchain-metadata.service.ts`

**Key Methods to Update**:
- `fetchMetadataFromUri()` - Add size limits, Content-Type checks
- `fetchMetadataFromUriWithRetry()` - Add URI validation before retries
- New: `validateUri()` - URI security validation
- New: `sanitizeMetadata()` - Prototype pollution protection, depth limits
- New: `safeJsonParse()` - Wrapper with size/depth checks
- New: `sanitizeUriForLogging()` - Safe logging

**Configuration Constants**:
```typescript
const MAX_METADATA_SIZE = 5 * 1024 * 1024; // 5MB
const MAX_JSON_DEPTH = 20;
const ALLOWED_URI_SCHEMES = ['https:', 'http:'];
const SUSPICIOUS_HOSTS = ['localhost', '127.0.0.1', '192.168', '10.', '172.16'];
```

**Error Handling**:
- Security rejections should NOT trigger retries
- Log security warnings separately from network errors
- Return clear error messages (without exposing internal details)

---

## Implementation Status

✅ **COMPLETE** - All security measures have been implemented and tested (2025-11-06).

**Implemented Features**:
1. ✅ Size limits (5MB max with streaming checks - prevents DoS)
2. ✅ URI validation (rejects IPs, private networks, localhost - prevents SSRF)
3. ✅ Prototype pollution protection (strips dangerous keys - prevents object contamination)
4. ✅ Depth limits (max 20 levels - prevents stack overflow)
5. ✅ Array/value limits (max 1000 elements, 10k char strings)
6. ✅ Content-Type verification (warns on unexpected types)
7. ✅ Enhanced logging (safe URI logging without credentials)
8. ✅ Retry logic updated (security errors don't trigger retries)
9. ✅ Comprehensive test suite (14 test cases, all passing)

---

## Testing

✅ **All tests passing** - Run `npx tsx src/scripts/test-metadata-security.ts` to verify.

**Test Coverage**:
- ✅ Localhost rejection (127.0.0.1, localhost, ::1)
- ✅ Private network rejection (192.168.x.x, 10.x.x.x, 172.16-31.x.x)
- ✅ Direct IP address rejection (observed: 95.179.167.134)
- ✅ Link-local address rejection (169.254.x.x)
- ✅ Valid IPFS gateway acceptance (ipfs.io, gateway.ipfs.io, cloudflare-ipfs.com)
- ✅ Valid Arweave gateway acceptance (arweave.net, gateway.arweave.net)
- ✅ Warning logging for non-trusted gateways
- ✅ Warning logging for unexpected Content-Types

**Test Files**:
- Unit tests: `test/security/ipfs-metadata-security.test.ts`
- Integration tests: `src/scripts/test-metadata-security.ts` (14 test cases, all passing)

---

## References

- **Patch Code**: See conversation history for full implementation
- **Affected Service**: `src/core/services/onchain-metadata.service.ts`
- **Related**: `src/scripts/fetch-token-metadata.ts` (also needs similar protection)

---

## Implementation Notes

- **Resilient Design**: Security errors are caught in `fetchSocialLinksBatch` and return null values, preventing crashes while still blocking malicious URIs
- **Comprehensive Logging**: All security violations are logged with sanitized URIs (no credentials exposed)
- **No Breaking Changes**: Implementation is backward compatible, existing functionality preserved
- **Performance Impact**: Minimal - validation happens before network requests
- **Monitoring**: Check logs for "Security validation failed" and "Security violation" warnings

## Post-Implementation Monitoring

Monitor logs for patterns:
- Frequency of blocked URIs
- New attack patterns (update validation rules if needed)
- Performance impact (should be negligible)
- False positives (legitimate services being blocked)

